/* tslint:disable */
/* eslint-disable */
/**
 * Loopstack API Documentation
 * Loopstack API Documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DashboardStatsDto
 */
export interface DashboardStatsDto {
    /**
     * Total number of workspaces
     * @type {number}
     * @memberof DashboardStatsDto
     */
    'workspaceCount': number;
    /**
     * Total number of automations
     * @type {number}
     * @memberof DashboardStatsDto
     */
    'totalAutomations': number;
    /**
     * Total number of automation runs
     * @type {number}
     * @memberof DashboardStatsDto
     */
    'totalAutomationRuns': number;
    /**
     * Number of completed runs
     * @type {number}
     * @memberof DashboardStatsDto
     */
    'completedRuns': number;
    /**
     * Number of runs with errors
     * @type {number}
     * @memberof DashboardStatsDto
     */
    'errorRuns': number;
    /**
     * Number of runs currently in progress
     * @type {number}
     * @memberof DashboardStatsDto
     */
    'inProgressRuns': number;
    /**
     * List of recent workflow errors
     * @type {Array<WorkflowDto>}
     * @memberof DashboardStatsDto
     */
    'recentErrors': Array<WorkflowDto>;
    /**
     * List of recent pipeline runs
     * @type {Array<PipelineDto>}
     * @memberof DashboardStatsDto
     */
    'recentRuns': Array<PipelineDto>;
}
/**
 * 
 * @export
 * @interface DocumentControllerGetDocuments200Response
 */
export interface DocumentControllerGetDocuments200Response {
    /**
     * 
     * @type {Array<DocumentItemDto>}
     * @memberof DocumentControllerGetDocuments200Response
     */
    'data': Array<DocumentItemDto>;
    /**
     * 
     * @type {number}
     * @memberof DocumentControllerGetDocuments200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof DocumentControllerGetDocuments200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof DocumentControllerGetDocuments200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface DocumentDto
 */
export interface DocumentDto {
    /**
     * Unique identifier of the document
     * @type {string}
     * @memberof DocumentDto
     */
    'id': string;
    /**
     * Name of the document
     * @type {string}
     * @memberof DocumentDto
     */
    'name': string;
    /**
     * Config key of the document
     * @type {string}
     * @memberof DocumentDto
     */
    'configKey': string;
    /**
     * Contents of the document
     * @type {object}
     * @memberof DocumentDto
     */
    'content': object;
    /**
     * The json schema for document validation
     * @type {object}
     * @memberof DocumentDto
     */
    'schema': object;
    /**
     * The zod validation error or null
     * @type {object}
     * @memberof DocumentDto
     */
    'validationError': object;
    /**
     * The ui config for interface rendering
     * @type {object}
     * @memberof DocumentDto
     */
    'ui': object;
    /**
     * Document metadata
     * @type {object}
     * @memberof DocumentDto
     */
    'meta': object;
    /**
     * Indicates if the document is invalidated
     * @type {boolean}
     * @memberof DocumentDto
     */
    'isInvalidated': boolean;
    /**
     * Indicates if the document is pending removal
     * @type {boolean}
     * @memberof DocumentDto
     */
    'isPendingRemoval': boolean;
    /**
     * Index of the document in the workflow
     * @type {number}
     * @memberof DocumentDto
     */
    'workflowIndex': number;
    /**
     * Version of the document
     * @type {number}
     * @memberof DocumentDto
     */
    'version': number;
    /**
     * Index of the document
     * @type {number}
     * @memberof DocumentDto
     */
    'index': number;
    /**
     * Transition when this document was created
     * @type {object}
     * @memberof DocumentDto
     */
    'transition': object;
    /**
     * Place when this document was created
     * @type {object}
     * @memberof DocumentDto
     */
    'place': object;
    /**
     * Labels associated with the document\'s namespace
     * @type {Array<string>}
     * @memberof DocumentDto
     */
    'labels': Array<string>;
    /**
     * Tags associated with the document for categorization and filtering
     * @type {Array<string>}
     * @memberof DocumentDto
     */
    'tags': Array<string>;
    /**
     * Date when the document was created
     * @type {string}
     * @memberof DocumentDto
     */
    'createdAt': string;
    /**
     * Date when the document was last updated
     * @type {string}
     * @memberof DocumentDto
     */
    'updatedAt': string;
    /**
     * ID of the workspace the document belongs to
     * @type {string}
     * @memberof DocumentDto
     */
    'workspaceId': string;
    /**
     * ID of the pipeline the document belongs to
     * @type {string}
     * @memberof DocumentDto
     */
    'pipelineId': string;
    /**
     * ID of the workflow the document belongs to
     * @type {string}
     * @memberof DocumentDto
     */
    'workflowId': string;
}
/**
 * 
 * @export
 * @interface DocumentFilterDto
 */
export interface DocumentFilterDto {
    /**
     * 
     * @type {string}
     * @memberof DocumentFilterDto
     */
    'workflowId'?: string;
}
/**
 * 
 * @export
 * @interface DocumentItemDto
 */
export interface DocumentItemDto {
    /**
     * Unique identifier of the document
     * @type {string}
     * @memberof DocumentItemDto
     */
    'id': string;
    /**
     * Name of the document
     * @type {string}
     * @memberof DocumentItemDto
     */
    'name': string;
    /**
     * Config key of the document
     * @type {string}
     * @memberof DocumentItemDto
     */
    'configKey': string;
    /**
     * Contents of the document
     * @type {object}
     * @memberof DocumentItemDto
     */
    'content': object;
    /**
     * The json schema for document validation
     * @type {object}
     * @memberof DocumentItemDto
     */
    'schema': object;
    /**
     * The zod validation error or null
     * @type {object}
     * @memberof DocumentItemDto
     */
    'validationError': object;
    /**
     * The ui config for interface rendering
     * @type {object}
     * @memberof DocumentItemDto
     */
    'ui': object;
    /**
     * Document metadata
     * @type {object}
     * @memberof DocumentItemDto
     */
    'meta': object;
    /**
     * Indicates if the document is invalidated
     * @type {boolean}
     * @memberof DocumentItemDto
     */
    'isInvalidated': boolean;
    /**
     * Indicates if the document is pending removal
     * @type {boolean}
     * @memberof DocumentItemDto
     */
    'isPendingRemoval': boolean;
    /**
     * Version of the document
     * @type {number}
     * @memberof DocumentItemDto
     */
    'version': number;
    /**
     * Index of the document
     * @type {number}
     * @memberof DocumentItemDto
     */
    'index': number;
    /**
     * Transition when this document was created
     * @type {object}
     * @memberof DocumentItemDto
     */
    'transition': object;
    /**
     * Place when this document was created
     * @type {string}
     * @memberof DocumentItemDto
     */
    'place': string | null;
    /**
     * Labels associated with the document\'s namespace
     * @type {Array<string>}
     * @memberof DocumentItemDto
     */
    'labels': Array<string>;
    /**
     * Tags associated with the document for categorization and filtering
     * @type {Array<string>}
     * @memberof DocumentItemDto
     */
    'tags': Array<string>;
    /**
     * Date when the document was created
     * @type {string}
     * @memberof DocumentItemDto
     */
    'createdAt': string;
    /**
     * Date when the document was last updated
     * @type {string}
     * @memberof DocumentItemDto
     */
    'updatedAt': string;
    /**
     * ID of the workspace the document belongs to
     * @type {string}
     * @memberof DocumentItemDto
     */
    'workspaceId': string;
    /**
     * ID of the pipeline the document belongs to
     * @type {string}
     * @memberof DocumentItemDto
     */
    'pipelineId': string;
    /**
     * ID of the workflow the document belongs to
     * @type {string}
     * @memberof DocumentItemDto
     */
    'workflowId': string;
}
/**
 * 
 * @export
 * @interface DocumentSortByDto
 */
export interface DocumentSortByDto {
    /**
     * 
     * @type {string}
     * @memberof DocumentSortByDto
     */
    'field': DocumentSortByDtoFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof DocumentSortByDto
     */
    'order': DocumentSortByDtoOrderEnum;
}

export const DocumentSortByDtoFieldEnum = {
    Id: 'id',
    Name: 'name',
    ConfigKey: 'configKey',
    WorkspaceId: 'workspaceId',
    PipelineId: 'pipelineId',
    Content: 'content',
    Schema: 'schema',
    ValidationError: 'validationError',
    Ui: 'ui',
    Tags: 'tags',
    Meta: 'meta',
    IsInvalidated: 'isInvalidated',
    IsPendingRemoval: 'isPendingRemoval',
    WorkflowIndex: 'workflowIndex',
    Version: 'version',
    Index: 'index',
    Transition: 'transition',
    Place: 'place',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    Labels: 'labels',
    WorkflowId: 'workflowId',
    CreatedBy: 'createdBy'
} as const;

export type DocumentSortByDtoFieldEnum = typeof DocumentSortByDtoFieldEnum[keyof typeof DocumentSortByDtoFieldEnum];
export const DocumentSortByDtoOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type DocumentSortByDtoOrderEnum = typeof DocumentSortByDtoOrderEnum[keyof typeof DocumentSortByDtoOrderEnum];

/**
 * 
 * @export
 * @interface HubLoginRequestDto
 */
export interface HubLoginRequestDto {
    /**
     * The authorization code
     * @type {string}
     * @memberof HubLoginRequestDto
     */
    'code': string;
    /**
     * The grant type
     * @type {string}
     * @memberof HubLoginRequestDto
     */
    'grantType': string;
}
/**
 * 
 * @export
 * @interface NamespaceControllerGetWorkflows200Response
 */
export interface NamespaceControllerGetWorkflows200Response {
    /**
     * 
     * @type {Array<NamespaceItemDto>}
     * @memberof NamespaceControllerGetWorkflows200Response
     */
    'data': Array<NamespaceItemDto>;
    /**
     * 
     * @type {number}
     * @memberof NamespaceControllerGetWorkflows200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceControllerGetWorkflows200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof NamespaceControllerGetWorkflows200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface NamespaceDto
 */
export interface NamespaceDto {
    /**
     * Unique identifier of the namespace
     * @type {string}
     * @memberof NamespaceDto
     */
    'id': string;
    /**
     * Name of the namespace
     * @type {string}
     * @memberof NamespaceDto
     */
    'name': string;
    /**
     * Unique identifier of the workspace this namespace belongs to
     * @type {string}
     * @memberof NamespaceDto
     */
    'workspaceId': string;
    /**
     * Unique identifier of the pipeline this namespace belongs to
     * @type {string}
     * @memberof NamespaceDto
     */
    'pipelineId': string;
    /**
     * Metadata of this namespace
     * @type {{ [key: string]: any; }}
     * @memberof NamespaceDto
     */
    'metadata': { [key: string]: any; };
    /**
     * Parent namespace ID
     * @type {string}
     * @memberof NamespaceDto
     */
    'parentId': string | null;
}
/**
 * 
 * @export
 * @interface NamespaceFilterDto
 */
export interface NamespaceFilterDto {
    /**
     * 
     * @type {string}
     * @memberof NamespaceFilterDto
     */
    'workspaceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NamespaceFilterDto
     */
    'pipelineId'?: string;
}
/**
 * 
 * @export
 * @interface NamespaceItemDto
 */
export interface NamespaceItemDto {
    /**
     * Unique identifier of the namespace
     * @type {string}
     * @memberof NamespaceItemDto
     */
    'id': string;
    /**
     * Name of the namespace
     * @type {string}
     * @memberof NamespaceItemDto
     */
    'name': string;
    /**
     * Metadata of this namespace
     * @type {{ [key: string]: any; }}
     * @memberof NamespaceItemDto
     */
    'metadata': { [key: string]: any; };
    /**
     * Parent namespace ID
     * @type {string}
     * @memberof NamespaceItemDto
     */
    'parentId': string | null;
}
/**
 * 
 * @export
 * @interface NamespaceSortByDto
 */
export interface NamespaceSortByDto {
    /**
     * 
     * @type {string}
     * @memberof NamespaceSortByDto
     */
    'field': NamespaceSortByDtoFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof NamespaceSortByDto
     */
    'order': NamespaceSortByDtoOrderEnum;
}

export const NamespaceSortByDtoFieldEnum = {
    Id: 'id',
    Name: 'name',
    WorkspaceId: 'workspaceId',
    PipelineId: 'pipelineId',
    ParentId: 'parentId',
    Metadata: 'metadata',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    CreatedBy: 'createdBy'
} as const;

export type NamespaceSortByDtoFieldEnum = typeof NamespaceSortByDtoFieldEnum[keyof typeof NamespaceSortByDtoFieldEnum];
export const NamespaceSortByDtoOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type NamespaceSortByDtoOrderEnum = typeof NamespaceSortByDtoOrderEnum[keyof typeof NamespaceSortByDtoOrderEnum];

/**
 * 
 * @export
 * @interface PaginatedDto
 */
export interface PaginatedDto {
    /**
     * 
     * @type {Array<object>}
     * @memberof PaginatedDto
     */
    'data': Array<object>;
    /**
     * 
     * @type {number}
     * @memberof PaginatedDto
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedDto
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedDto
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface PipelineConfigDto
 */
export interface PipelineConfigDto {
    /**
     * The config Key of the pipeline
     * @type {string}
     * @memberof PipelineConfigDto
     */
    'configKey': string;
    /**
     * The title of the pipeline type
     * @type {string}
     * @memberof PipelineConfigDto
     */
    'title'?: string;
    /**
     * The workspace type for this pipeline
     * @type {string}
     * @memberof PipelineConfigDto
     */
    'workspace': string;
}
/**
 * 
 * @export
 * @interface PipelineControllerBatchDeletePipelines200Response
 */
export interface PipelineControllerBatchDeletePipelines200Response {
    /**
     * Successfully deleted pipeline IDs
     * @type {Array<string>}
     * @memberof PipelineControllerBatchDeletePipelines200Response
     */
    'deleted'?: Array<string>;
    /**
     * Failed deletions with error details
     * @type {Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>}
     * @memberof PipelineControllerBatchDeletePipelines200Response
     */
    'failed'?: Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>;
}
/**
 * 
 * @export
 * @interface PipelineControllerBatchDeletePipelines200ResponseFailedInner
 */
export interface PipelineControllerBatchDeletePipelines200ResponseFailedInner {
    /**
     * 
     * @type {string}
     * @memberof PipelineControllerBatchDeletePipelines200ResponseFailedInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PipelineControllerBatchDeletePipelines200ResponseFailedInner
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface PipelineControllerBatchDeletePipelinesRequest
 */
export interface PipelineControllerBatchDeletePipelinesRequest {
    /**
     * Array of pipeline IDs to delete
     * @type {Array<string>}
     * @memberof PipelineControllerBatchDeletePipelinesRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface PipelineControllerGetPipelines200Response
 */
export interface PipelineControllerGetPipelines200Response {
    /**
     * 
     * @type {Array<PipelineItemDto>}
     * @memberof PipelineControllerGetPipelines200Response
     */
    'data': Array<PipelineItemDto>;
    /**
     * 
     * @type {number}
     * @memberof PipelineControllerGetPipelines200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof PipelineControllerGetPipelines200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof PipelineControllerGetPipelines200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface PipelineCreateDto
 */
export interface PipelineCreateDto {
    /**
     * Process config key identifier for the pipeline
     * @type {string}
     * @memberof PipelineCreateDto
     */
    'configKey': string;
    /**
     * Human-readable title for the pipeline
     * @type {string}
     * @memberof PipelineCreateDto
     */
    'title': string;
    /**
     * Array of labels/tags associated with the pipeline
     * @type {Array<string>}
     * @memberof PipelineCreateDto
     */
    'labels'?: Array<string>;
    /**
     * UUID of the workspace the pipeline belongs to
     * @type {string}
     * @memberof PipelineCreateDto
     */
    'workspaceId': string;
}
/**
 * 
 * @export
 * @interface PipelineDto
 */
export interface PipelineDto {
    /**
     * Unique identifier of the pipeline
     * @type {string}
     * @memberof PipelineDto
     */
    'id': string;
    /**
     * Config key of the pipeline
     * @type {string}
     * @memberof PipelineDto
     */
    'configKey': string;
    /**
     * Display title of the pipeline
     * @type {string}
     * @memberof PipelineDto
     */
    'title': string;
    /**
     * Tags associated with the pipeline for categorization and filtering
     * @type {Array<string>}
     * @memberof PipelineDto
     */
    'labels': Array<string>;
    /**
     * Order position of the pipeline in listings
     * @type {number}
     * @memberof PipelineDto
     */
    'order': number;
    /**
     * Current status of the pipeline
     * @type {PipelineStatus}
     * @memberof PipelineDto
     */
    'status': PipelineStatus;
    /**
     * Contextual information available to the pipeline
     * @type {object}
     * @memberof PipelineDto
     */
    'context': object;
    /**
     * Timestamp when the pipeline was created
     * @type {string}
     * @memberof PipelineDto
     */
    'createdAt': string;
    /**
     * Timestamp when the pipeline was last updated
     * @type {string}
     * @memberof PipelineDto
     */
    'updatedAt': string;
    /**
     * Identifier of the workspace that contains this pipeline
     * @type {string}
     * @memberof PipelineDto
     */
    'workspaceId': string;
}


/**
 * 
 * @export
 * @interface PipelineFilterDto
 */
export interface PipelineFilterDto {
    /**
     * 
     * @type {string}
     * @memberof PipelineFilterDto
     */
    'workspaceId'?: string;
}
/**
 * 
 * @export
 * @interface PipelineItemDto
 */
export interface PipelineItemDto {
    /**
     * Unique identifier of the pipeline
     * @type {string}
     * @memberof PipelineItemDto
     */
    'id': string;
    /**
     * Config key of the pipeline
     * @type {string}
     * @memberof PipelineItemDto
     */
    'configKey': string;
    /**
     * Display title of the pipeline
     * @type {string}
     * @memberof PipelineItemDto
     */
    'title': string;
    /**
     * Tags associated with the pipeline for categorization and filtering
     * @type {Array<string>}
     * @memberof PipelineItemDto
     */
    'labels': Array<string>;
    /**
     * Order position of the pipeline in listings
     * @type {number}
     * @memberof PipelineItemDto
     */
    'order': number;
    /**
     * Current status of the pipeline
     * @type {PipelineStatus}
     * @memberof PipelineItemDto
     */
    'status': PipelineStatus;
    /**
     * Timestamp when the pipeline was created
     * @type {string}
     * @memberof PipelineItemDto
     */
    'createdAt': string;
    /**
     * Timestamp when the pipeline was last updated
     * @type {string}
     * @memberof PipelineItemDto
     */
    'updatedAt': string;
    /**
     * Identifier of the workspace that contains this pipeline
     * @type {string}
     * @memberof PipelineItemDto
     */
    'workspaceId': string;
}


/**
 * 
 * @export
 * @interface PipelineSortByDto
 */
export interface PipelineSortByDto {
    /**
     * 
     * @type {string}
     * @memberof PipelineSortByDto
     */
    'field': PipelineSortByDtoFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof PipelineSortByDto
     */
    'order': PipelineSortByDtoOrderEnum;
}

export const PipelineSortByDtoFieldEnum = {
    Id: 'id',
    ConfigKey: 'configKey',
    Title: 'title',
    Labels: 'labels',
    Index: 'index',
    Status: 'status',
    Context: 'context',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    WorkspaceId: 'workspaceId',
    CreatedBy: 'createdBy'
} as const;

export type PipelineSortByDtoFieldEnum = typeof PipelineSortByDtoFieldEnum[keyof typeof PipelineSortByDtoFieldEnum];
export const PipelineSortByDtoOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type PipelineSortByDtoOrderEnum = typeof PipelineSortByDtoOrderEnum[keyof typeof PipelineSortByDtoOrderEnum];

/**
 * Current status of the pipeline
 * @export
 * @enum {string}
 */

export const PipelineStatus = {
    Pending: 'pending',
    Running: 'running',
    Paused: 'paused',
    Completed: 'completed',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;

export type PipelineStatus = typeof PipelineStatus[keyof typeof PipelineStatus];


/**
 * 
 * @export
 * @interface PipelineUpdateDto
 */
export interface PipelineUpdateDto {
    /**
     * Human-readable title for the pipeline
     * @type {string}
     * @memberof PipelineUpdateDto
     */
    'title'?: string;
    /**
     * Array of labels/tags associated with the pipeline
     * @type {Array<string>}
     * @memberof PipelineUpdateDto
     */
    'labels'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RunPipelinePayloadDto
 */
export interface RunPipelinePayloadDto {
    /**
     * 
     * @type {object}
     * @memberof RunPipelinePayloadDto
     */
    'transition'?: object;
}
/**
 * 
 * @export
 * @interface WorkerInfoDto
 */
export interface WorkerInfoDto {
    /**
     * Worker Client ID
     * @type {string}
     * @memberof WorkerInfoDto
     */
    'clientId'?: string;
    /**
     * Is worker configured.
     * @type {boolean}
     * @memberof WorkerInfoDto
     */
    'isConfigured': boolean;
}
/**
 * 
 * @export
 * @interface WorkflowControllerGetWorkflows200Response
 */
export interface WorkflowControllerGetWorkflows200Response {
    /**
     * 
     * @type {Array<WorkflowItemDto>}
     * @memberof WorkflowControllerGetWorkflows200Response
     */
    'data': Array<WorkflowItemDto>;
    /**
     * 
     * @type {number}
     * @memberof WorkflowControllerGetWorkflows200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowControllerGetWorkflows200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof WorkflowControllerGetWorkflows200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface WorkflowDto
 */
export interface WorkflowDto {
    /**
     * Unique identifier of the workflow
     * @type {string}
     * @memberof WorkflowDto
     */
    'id': string;
    /**
     * Config key of the workflow
     * @type {string}
     * @memberof WorkflowDto
     */
    'configKey': string;
    /**
     * Display title of the workflow
     * @type {string}
     * @memberof WorkflowDto
     */
    'title': string;
    /**
     * Index position of the workflow in the pipeline sequence
     * @type {number}
     * @memberof WorkflowDto
     */
    'index': number;
    /**
     * Tags associated with the workflow for categorization and filtering
     * @type {Array<string>}
     * @memberof WorkflowDto
     */
    'labels': Array<string>;
    /**
     * Completion percentage of the workflow (0-100)
     * @type {number}
     * @memberof WorkflowDto
     */
    'progress': number;
    /**
     * Error message if workflow execution failed
     * @type {string}
     * @memberof WorkflowDto
     */
    'error'?: string | null;
    /**
     * Current status of the workflow
     * @type {WorkflowState}
     * @memberof WorkflowDto
     */
    'status': WorkflowState;
    /**
     * Current place in the workflow state machine
     * @type {string}
     * @memberof WorkflowDto
     */
    'place': string;
    /**
     * Additional information about the current place in the workflow
     * @type {object}
     * @memberof WorkflowDto
     */
    'placeInfo'?: object | null;
    /**
     * History of state transitions within the workflow
     * @type {object}
     * @memberof WorkflowDto
     */
    'transitionHistory'?: object | null;
    /**
     * Ui schema config for the workflow
     * @type {{ [key: string]: any; }}
     * @memberof WorkflowDto
     */
    'ui'?: { [key: string]: any; } | null;
    /**
     * Date and time when the workflow was created
     * @type {string}
     * @memberof WorkflowDto
     */
    'createdAt': string;
    /**
     * Date and time when the workflow was last updated
     * @type {string}
     * @memberof WorkflowDto
     */
    'updatedAt': string;
    /**
     * Unique identifier of the workspace this workflow belongs to
     * @type {string}
     * @memberof WorkflowDto
     */
    'workspaceId': string;
    /**
     * Unique identifier of the pipeline this workflow belongs to
     * @type {string}
     * @memberof WorkflowDto
     */
    'pipelineId': string;
    /**
     * Unique identifier of the namespace this workflow belongs to
     * @type {string}
     * @memberof WorkflowDto
     */
    'namespaceId': string;
}


/**
 * 
 * @export
 * @interface WorkflowFilterDto
 */
export interface WorkflowFilterDto {
    /**
     * 
     * @type {string}
     * @memberof WorkflowFilterDto
     */
    'namespaceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowFilterDto
     */
    'pipelineId'?: string;
}
/**
 * 
 * @export
 * @interface WorkflowItemDto
 */
export interface WorkflowItemDto {
    /**
     * Unique identifier of the workflow item
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'id': string;
    /**
     * Config key of the workflow
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'configKey': string;
    /**
     * Display title of the workflow
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'title': string;
    /**
     * Index position of the workflow item in a sequence
     * @type {number}
     * @memberof WorkflowItemDto
     */
    'index': number;
    /**
     * Tags associated with the workflow for categorization and filtering
     * @type {Array<string>}
     * @memberof WorkflowItemDto
     */
    'labels': Array<string>;
    /**
     * Completion percentage of the workflow item (0-100)
     * @type {number}
     * @memberof WorkflowItemDto
     */
    'progress': number;
    /**
     * Error message if workflow execution failed
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'error'?: string | null;
    /**
     * Current status of the workflow
     * @type {WorkflowState}
     * @memberof WorkflowItemDto
     */
    'status': WorkflowState;
    /**
     * Date and time when the workflow item was created
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'createdAt': string;
    /**
     * Date and time when the workflow item was last updated
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'updatedAt': string;
    /**
     * Current place in the workflow state machine
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'place': string;
    /**
     * Additional information about the current place in the workflow
     * @type {object}
     * @memberof WorkflowItemDto
     */
    'placeInfo'?: object | null;
    /**
     * Unique identifier of the workspace this workflow item belongs to
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'workspaceId': string;
    /**
     * Unique identifier of the pipeline this workflow belongs to
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'pipelineId': string;
    /**
     * Unique identifier of the namespace this workflow belongs to
     * @type {string}
     * @memberof WorkflowItemDto
     */
    'namespaceId': string;
}


/**
 * 
 * @export
 * @interface WorkflowSortByDto
 */
export interface WorkflowSortByDto {
    /**
     * 
     * @type {string}
     * @memberof WorkflowSortByDto
     */
    'field': WorkflowSortByDtoFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkflowSortByDto
     */
    'order': WorkflowSortByDtoOrderEnum;
}

export const WorkflowSortByDtoFieldEnum = {
    Id: 'id',
    ConfigKey: 'configKey',
    Title: 'title',
    Index: 'index',
    Progress: 'progress',
    Status: 'status',
    Error: 'error',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    Place: 'place',
    PrevData: 'prevData',
    CurrData: 'currData',
    AliasData: 'aliasData',
    ContextVariables: 'contextVariables',
    PlaceInfo: 'placeInfo',
    History: 'history',
    Ui: 'ui',
    NamespaceId: 'namespaceId',
    PipelineId: 'pipelineId',
    Labels: 'labels',
    HashRecord: 'hashRecord',
    CreatedBy: 'createdBy'
} as const;

export type WorkflowSortByDtoFieldEnum = typeof WorkflowSortByDtoFieldEnum[keyof typeof WorkflowSortByDtoFieldEnum];
export const WorkflowSortByDtoOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type WorkflowSortByDtoOrderEnum = typeof WorkflowSortByDtoOrderEnum[keyof typeof WorkflowSortByDtoOrderEnum];

/**
 * Current status of the workflow
 * @export
 * @enum {string}
 */

export const WorkflowState = {
    Pending: 'pending',
    Running: 'running',
    Waiting: 'waiting',
    Completed: 'completed',
    Failed: 'failed',
    Canceled: 'canceled'
} as const;

export type WorkflowState = typeof WorkflowState[keyof typeof WorkflowState];


/**
 * 
 * @export
 * @interface WorkspaceConfigDto
 */
export interface WorkspaceConfigDto {
    /**
     * Config key of the workspace
     * @type {string}
     * @memberof WorkspaceConfigDto
     */
    'configKey': string;
    /**
     * The title of the workspace type
     * @type {string}
     * @memberof WorkspaceConfigDto
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface WorkspaceControllerBatchDeleteWorkspaces200Response
 */
export interface WorkspaceControllerBatchDeleteWorkspaces200Response {
    /**
     * Successfully deleted workspace IDs
     * @type {Array<string>}
     * @memberof WorkspaceControllerBatchDeleteWorkspaces200Response
     */
    'deleted'?: Array<string>;
    /**
     * Failed deletions with error details
     * @type {Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>}
     * @memberof WorkspaceControllerBatchDeleteWorkspaces200Response
     */
    'failed'?: Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>;
}
/**
 * 
 * @export
 * @interface WorkspaceControllerBatchDeleteWorkspacesRequest
 */
export interface WorkspaceControllerBatchDeleteWorkspacesRequest {
    /**
     * Array of workspace IDs to delete
     * @type {Array<string>}
     * @memberof WorkspaceControllerBatchDeleteWorkspacesRequest
     */
    'ids': Array<string>;
}
/**
 * 
 * @export
 * @interface WorkspaceControllerGetWorkspaces200Response
 */
export interface WorkspaceControllerGetWorkspaces200Response {
    /**
     * 
     * @type {Array<WorkspaceItemDto>}
     * @memberof WorkspaceControllerGetWorkspaces200Response
     */
    'data': Array<WorkspaceItemDto>;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceControllerGetWorkspaces200Response
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceControllerGetWorkspaces200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof WorkspaceControllerGetWorkspaces200Response
     */
    'limit': number;
}
/**
 * 
 * @export
 * @interface WorkspaceCreateDto
 */
export interface WorkspaceCreateDto {
    /**
     * Human-readable title for the workspace
     * @type {string}
     * @memberof WorkspaceCreateDto
     */
    'title'?: string;
    /**
     * The config key of the workspace
     * @type {string}
     * @memberof WorkspaceCreateDto
     */
    'configKey': string;
}
/**
 * 
 * @export
 * @interface WorkspaceDto
 */
export interface WorkspaceDto {
    /**
     * Unique identifier of the workspace
     * @type {string}
     * @memberof WorkspaceDto
     */
    'id': string;
    /**
     * Config key of the workspace
     * @type {string}
     * @memberof WorkspaceDto
     */
    'configKey': string;
    /**
     * Display title of the workspace
     * @type {string}
     * @memberof WorkspaceDto
     */
    'title': string;
    /**
     * Indicates whether the workspace is locked for editing
     * @type {boolean}
     * @memberof WorkspaceDto
     */
    'isLocked': boolean;
    /**
     * Timestamp when the workspace was created
     * @type {string}
     * @memberof WorkspaceDto
     */
    'createdAt': string;
    /**
     * Timestamp when the workspace was last updated
     * @type {string}
     * @memberof WorkspaceDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface WorkspaceItemDto
 */
export interface WorkspaceItemDto {
    /**
     * Unique identifier of the workspace item
     * @type {string}
     * @memberof WorkspaceItemDto
     */
    'id': string;
    /**
     * Config key of the workspace
     * @type {string}
     * @memberof WorkspaceItemDto
     */
    'configKey': string;
    /**
     * Display title of the workspace
     * @type {string}
     * @memberof WorkspaceItemDto
     */
    'title': string;
    /**
     * Timestamp when the workspace item was created
     * @type {string}
     * @memberof WorkspaceItemDto
     */
    'createdAt': string;
    /**
     * Timestamp when the workspace item was last updated
     * @type {string}
     * @memberof WorkspaceItemDto
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface WorkspaceSortByDto
 */
export interface WorkspaceSortByDto {
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSortByDto
     */
    'field': WorkspaceSortByDtoFieldEnum;
    /**
     * 
     * @type {string}
     * @memberof WorkspaceSortByDto
     */
    'order': WorkspaceSortByDtoOrderEnum;
}

export const WorkspaceSortByDtoFieldEnum = {
    Id: 'id',
    Title: 'title',
    ConfigKey: 'configKey',
    CreatedAt: 'createdAt',
    UpdatedAt: 'updatedAt',
    CreatedBy: 'createdBy'
} as const;

export type WorkspaceSortByDtoFieldEnum = typeof WorkspaceSortByDtoFieldEnum[keyof typeof WorkspaceSortByDtoFieldEnum];
export const WorkspaceSortByDtoOrderEnum = {
    Asc: 'ASC',
    Desc: 'DESC'
} as const;

export type WorkspaceSortByDtoOrderEnum = typeof WorkspaceSortByDtoOrderEnum[keyof typeof WorkspaceSortByDtoOrderEnum];

/**
 * 
 * @export
 * @interface WorkspaceUpdateDto
 */
export interface WorkspaceUpdateDto {
    /**
     * Human-readable title for the workspace
     * @type {string}
     * @memberof WorkspaceUpdateDto
     */
    'title'?: string;
}

/**
 * ApiV1AuthApi - axios parameter creator
 * @export
 */
export const ApiV1AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/worker/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login via Hub
         * @param {HubLoginRequestDto} hubLoginRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerHubLogin: async (hubLoginRequestDto: HubLoginRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hubLoginRequestDto' is not null or undefined
            assertParamExists('authControllerHubLogin', 'hubLoginRequestDto', hubLoginRequestDto)
            const localVarPath = `/api/v1/auth/oauth/hub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hubLoginRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1AuthApi - functional programming interface
 * @export
 */
export const ApiV1AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1AuthApi.authControllerGetInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login via Hub
         * @param {HubLoginRequestDto} hubLoginRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerHubLogin(hubLoginRequestDto: HubLoginRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerHubLogin(hubLoginRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1AuthApi.authControllerHubLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1AuthApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1AuthApi.authControllerMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefresh(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1AuthApi.authControllerRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1AuthApi - factory interface
 * @export
 */
export const ApiV1AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetInfo(options?: RawAxiosRequestConfig): AxiosPromise<WorkerInfoDto> {
            return localVarFp.authControllerGetInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login via Hub
         * @param {ApiV1AuthApiAuthControllerHubLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerHubLogin(requestParameters: ApiV1AuthApiAuthControllerHubLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerHubLogin(requestParameters.hubLoginRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerRefresh(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1AuthApi - interface
 * @export
 * @interface ApiV1AuthApi
 */
export interface ApiV1AuthApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApiInterface
     */
    authControllerGetInfo(options?: RawAxiosRequestConfig): AxiosPromise<WorkerInfoDto>;

    /**
     * 
     * @summary Login via Hub
     * @param {ApiV1AuthApiAuthControllerHubLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApiInterface
     */
    authControllerHubLogin(requestParameters: ApiV1AuthApiAuthControllerHubLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApiInterface
     */
    authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApiInterface
     */
    authControllerMe(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApiInterface
     */
    authControllerRefresh(options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for authControllerHubLogin operation in ApiV1AuthApi.
 * @export
 * @interface ApiV1AuthApiAuthControllerHubLoginRequest
 */
export interface ApiV1AuthApiAuthControllerHubLoginRequest {
    /**
     * 
     * @type {HubLoginRequestDto}
     * @memberof ApiV1AuthApiAuthControllerHubLogin
     */
    readonly hubLoginRequestDto: HubLoginRequestDto
}

/**
 * ApiV1AuthApi - object-oriented interface
 * @export
 * @class ApiV1AuthApi
 * @extends {BaseAPI}
 */
export class ApiV1AuthApi extends BaseAPI implements ApiV1AuthApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApi
     */
    public authControllerGetInfo(options?: RawAxiosRequestConfig) {
        return ApiV1AuthApiFp(this.configuration).authControllerGetInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login via Hub
     * @param {ApiV1AuthApiAuthControllerHubLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApi
     */
    public authControllerHubLogin(requestParameters: ApiV1AuthApiAuthControllerHubLoginRequest, options?: RawAxiosRequestConfig) {
        return ApiV1AuthApiFp(this.configuration).authControllerHubLogin(requestParameters.hubLoginRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApi
     */
    public authControllerLogout(options?: RawAxiosRequestConfig) {
        return ApiV1AuthApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApi
     */
    public authControllerMe(options?: RawAxiosRequestConfig) {
        return ApiV1AuthApiFp(this.configuration).authControllerMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1AuthApi
     */
    public authControllerRefresh(options?: RawAxiosRequestConfig) {
        return ApiV1AuthApiFp(this.configuration).authControllerRefresh(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1ConfigApi - axios parameter creator
 * @export
 */
export const ApiV1ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all pipeline types available for this workspace
         * @param {string} workspaceConfigKey The config key of the workspace type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerGetPipelineTypesByWorkspace: async (workspaceConfigKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceConfigKey' is not null or undefined
            assertParamExists('configControllerGetPipelineTypesByWorkspace', 'workspaceConfigKey', workspaceConfigKey)
            const localVarPath = `/api/v1/config/workspaces/{workspaceConfigKey}/pipelines`
                .replace(`{${"workspaceConfigKey"}}`, encodeURIComponent(String(workspaceConfigKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all models available for this workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerGetWorkspaceTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/config/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1ConfigApi - functional programming interface
 * @export
 */
export const ApiV1ConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1ConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all pipeline types available for this workspace
         * @param {string} workspaceConfigKey The config key of the workspace type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configControllerGetPipelineTypesByWorkspace(workspaceConfigKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineConfigDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configControllerGetPipelineTypesByWorkspace(workspaceConfigKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1ConfigApi.configControllerGetPipelineTypesByWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all models available for this workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async configControllerGetWorkspaceTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceConfigDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.configControllerGetWorkspaceTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1ConfigApi.configControllerGetWorkspaceTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1ConfigApi - factory interface
 * @export
 */
export const ApiV1ConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1ConfigApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all pipeline types available for this workspace
         * @param {ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerGetPipelineTypesByWorkspace(requestParameters: ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PipelineConfigDto>> {
            return localVarFp.configControllerGetPipelineTypesByWorkspace(requestParameters.workspaceConfigKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all models available for this workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        configControllerGetWorkspaceTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceConfigDto>> {
            return localVarFp.configControllerGetWorkspaceTypes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1ConfigApi - interface
 * @export
 * @interface ApiV1ConfigApi
 */
export interface ApiV1ConfigApiInterface {
    /**
     * 
     * @summary Get all pipeline types available for this workspace
     * @param {ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1ConfigApiInterface
     */
    configControllerGetPipelineTypesByWorkspace(requestParameters: ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PipelineConfigDto>>;

    /**
     * 
     * @summary Get all models available for this workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1ConfigApiInterface
     */
    configControllerGetWorkspaceTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceConfigDto>>;

}

/**
 * Request parameters for configControllerGetPipelineTypesByWorkspace operation in ApiV1ConfigApi.
 * @export
 * @interface ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest
 */
export interface ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest {
    /**
     * The config key of the workspace type
     * @type {string}
     * @memberof ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspace
     */
    readonly workspaceConfigKey: string
}

/**
 * ApiV1ConfigApi - object-oriented interface
 * @export
 * @class ApiV1ConfigApi
 * @extends {BaseAPI}
 */
export class ApiV1ConfigApi extends BaseAPI implements ApiV1ConfigApiInterface {
    /**
     * 
     * @summary Get all pipeline types available for this workspace
     * @param {ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1ConfigApi
     */
    public configControllerGetPipelineTypesByWorkspace(requestParameters: ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return ApiV1ConfigApiFp(this.configuration).configControllerGetPipelineTypesByWorkspace(requestParameters.workspaceConfigKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all models available for this workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1ConfigApi
     */
    public configControllerGetWorkspaceTypes(options?: RawAxiosRequestConfig) {
        return ApiV1ConfigApiFp(this.configuration).configControllerGetWorkspaceTypes(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1DashboardApi - axios parameter creator
 * @export
 */
export const ApiV1DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves aggregated statistics for all automations across all workspaces
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerGetDashboardStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1DashboardApi - functional programming interface
 * @export
 */
export const ApiV1DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves aggregated statistics for all automations across all workspaces
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dashboardControllerGetDashboardStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardStatsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardControllerGetDashboardStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1DashboardApi.dashboardControllerGetDashboardStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1DashboardApi - factory interface
 * @export
 */
export const ApiV1DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1DashboardApiFp(configuration)
    return {
        /**
         * Retrieves aggregated statistics for all automations across all workspaces
         * @summary Get dashboard statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dashboardControllerGetDashboardStats(options?: RawAxiosRequestConfig): AxiosPromise<DashboardStatsDto> {
            return localVarFp.dashboardControllerGetDashboardStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1DashboardApi - interface
 * @export
 * @interface ApiV1DashboardApi
 */
export interface ApiV1DashboardApiInterface {
    /**
     * Retrieves aggregated statistics for all automations across all workspaces
     * @summary Get dashboard statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1DashboardApiInterface
     */
    dashboardControllerGetDashboardStats(options?: RawAxiosRequestConfig): AxiosPromise<DashboardStatsDto>;

}

/**
 * ApiV1DashboardApi - object-oriented interface
 * @export
 * @class ApiV1DashboardApi
 * @extends {BaseAPI}
 */
export class ApiV1DashboardApi extends BaseAPI implements ApiV1DashboardApiInterface {
    /**
     * Retrieves aggregated statistics for all automations across all workspaces
     * @summary Get dashboard statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1DashboardApi
     */
    public dashboardControllerGetDashboardStats(options?: RawAxiosRequestConfig) {
        return ApiV1DashboardApiFp(this.configuration).dashboardControllerGetDashboardStats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1DocumentsApi - axios parameter creator
 * @export
 */
export const ApiV1DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a document by ID
         * @param {string} id The ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocumentById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentControllerGetDocumentById', 'id', id)
            const localVarPath = `/api/v1/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve documents with filters, sorting, and pagination
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of DocumentFilterDto object
         * @param {string} [sortBy] JSON string array of DocumentSortByDto objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocuments: async (page?: number, limit?: number, filter?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1DocumentsApi - functional programming interface
 * @export
 */
export const ApiV1DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a document by ID
         * @param {string} id The ID of the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetDocumentById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocumentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1DocumentsApi.documentControllerGetDocumentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve documents with filters, sorting, and pagination
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of DocumentFilterDto object
         * @param {string} [sortBy] JSON string array of DocumentSortByDto objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentControllerGetDocuments(page?: number, limit?: number, filter?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentControllerGetDocuments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocuments(page, limit, filter, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1DocumentsApi.documentControllerGetDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1DocumentsApi - factory interface
 * @export
 */
export const ApiV1DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a document by ID
         * @param {ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocumentById(requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentDto> {
            return localVarFp.documentControllerGetDocumentById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve documents with filters, sorting, and pagination
         * @param {ApiV1DocumentsApiDocumentControllerGetDocumentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentControllerGetDocuments(requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DocumentControllerGetDocuments200Response> {
            return localVarFp.documentControllerGetDocuments(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1DocumentsApi - interface
 * @export
 * @interface ApiV1DocumentsApi
 */
export interface ApiV1DocumentsApiInterface {
    /**
     * 
     * @summary Get a document by ID
     * @param {ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1DocumentsApiInterface
     */
    documentControllerGetDocumentById(requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentDto>;

    /**
     * 
     * @summary Retrieve documents with filters, sorting, and pagination
     * @param {ApiV1DocumentsApiDocumentControllerGetDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1DocumentsApiInterface
     */
    documentControllerGetDocuments(requestParameters?: ApiV1DocumentsApiDocumentControllerGetDocumentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentControllerGetDocuments200Response>;

}

/**
 * Request parameters for documentControllerGetDocumentById operation in ApiV1DocumentsApi.
 * @export
 * @interface ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest
 */
export interface ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest {
    /**
     * The ID of the document
     * @type {string}
     * @memberof ApiV1DocumentsApiDocumentControllerGetDocumentById
     */
    readonly id: string
}

/**
 * Request parameters for documentControllerGetDocuments operation in ApiV1DocumentsApi.
 * @export
 * @interface ApiV1DocumentsApiDocumentControllerGetDocumentsRequest
 */
export interface ApiV1DocumentsApiDocumentControllerGetDocumentsRequest {
    /**
     * Page number for pagination (starts at 1)
     * @type {number}
     * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
     */
    readonly limit?: number

    /**
     * JSON string of DocumentFilterDto object
     * @type {string}
     * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
     */
    readonly filter?: string

    /**
     * JSON string array of DocumentSortByDto objects
     * @type {string}
     * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
     */
    readonly sortBy?: string
}

/**
 * ApiV1DocumentsApi - object-oriented interface
 * @export
 * @class ApiV1DocumentsApi
 * @extends {BaseAPI}
 */
export class ApiV1DocumentsApi extends BaseAPI implements ApiV1DocumentsApiInterface {
    /**
     * 
     * @summary Get a document by ID
     * @param {ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1DocumentsApi
     */
    public documentControllerGetDocumentById(requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest, options?: RawAxiosRequestConfig) {
        return ApiV1DocumentsApiFp(this.configuration).documentControllerGetDocumentById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve documents with filters, sorting, and pagination
     * @param {ApiV1DocumentsApiDocumentControllerGetDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1DocumentsApi
     */
    public documentControllerGetDocuments(requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentsRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiV1DocumentsApiFp(this.configuration).documentControllerGetDocuments(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1NamespacesApi - axios parameter creator
 * @export
 */
export const ApiV1NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a namespace by ID
         * @param {string} id The ID of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceControllerGetWorkflowById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('namespaceControllerGetWorkflowById', 'id', id)
            const localVarPath = `/api/v1/namespaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve namespaces with filters, sorting, and pagination
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of NamespaceFilterDto object
         * @param {string} [sortBy] JSON string array of NamespaceSortByDto objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceControllerGetWorkflows: async (page?: number, limit?: number, filter?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1NamespacesApi - functional programming interface
 * @export
 */
export const ApiV1NamespacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1NamespacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a namespace by ID
         * @param {string} id The ID of the namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceControllerGetWorkflowById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamespaceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.namespaceControllerGetWorkflowById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1NamespacesApi.namespaceControllerGetWorkflowById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve namespaces with filters, sorting, and pagination
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of NamespaceFilterDto object
         * @param {string} [sortBy] JSON string array of NamespaceSortByDto objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceControllerGetWorkflows(page?: number, limit?: number, filter?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamespaceControllerGetWorkflows200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.namespaceControllerGetWorkflows(page, limit, filter, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1NamespacesApi.namespaceControllerGetWorkflows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1NamespacesApi - factory interface
 * @export
 */
export const ApiV1NamespacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1NamespacesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a namespace by ID
         * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceControllerGetWorkflowById(requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<NamespaceDto> {
            return localVarFp.namespaceControllerGetWorkflowById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve namespaces with filters, sorting, and pagination
         * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceControllerGetWorkflows(requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<NamespaceControllerGetWorkflows200Response> {
            return localVarFp.namespaceControllerGetWorkflows(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1NamespacesApi - interface
 * @export
 * @interface ApiV1NamespacesApi
 */
export interface ApiV1NamespacesApiInterface {
    /**
     * 
     * @summary Get a namespace by ID
     * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1NamespacesApiInterface
     */
    namespaceControllerGetWorkflowById(requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<NamespaceDto>;

    /**
     * 
     * @summary Retrieve namespaces with filters, sorting, and pagination
     * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1NamespacesApiInterface
     */
    namespaceControllerGetWorkflows(requestParameters?: ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest, options?: RawAxiosRequestConfig): AxiosPromise<NamespaceControllerGetWorkflows200Response>;

}

/**
 * Request parameters for namespaceControllerGetWorkflowById operation in ApiV1NamespacesApi.
 * @export
 * @interface ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest
 */
export interface ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest {
    /**
     * The ID of the namespace
     * @type {string}
     * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflowById
     */
    readonly id: string
}

/**
 * Request parameters for namespaceControllerGetWorkflows operation in ApiV1NamespacesApi.
 * @export
 * @interface ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest
 */
export interface ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest {
    /**
     * Page number for pagination (starts at 1)
     * @type {number}
     * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
     */
    readonly limit?: number

    /**
     * JSON string of NamespaceFilterDto object
     * @type {string}
     * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
     */
    readonly filter?: string

    /**
     * JSON string array of NamespaceSortByDto objects
     * @type {string}
     * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
     */
    readonly sortBy?: string
}

/**
 * ApiV1NamespacesApi - object-oriented interface
 * @export
 * @class ApiV1NamespacesApi
 * @extends {BaseAPI}
 */
export class ApiV1NamespacesApi extends BaseAPI implements ApiV1NamespacesApiInterface {
    /**
     * 
     * @summary Get a namespace by ID
     * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1NamespacesApi
     */
    public namespaceControllerGetWorkflowById(requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest, options?: RawAxiosRequestConfig) {
        return ApiV1NamespacesApiFp(this.configuration).namespaceControllerGetWorkflowById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve namespaces with filters, sorting, and pagination
     * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1NamespacesApi
     */
    public namespaceControllerGetWorkflows(requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiV1NamespacesApiFp(this.configuration).namespaceControllerGetWorkflows(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1PipelinesApi - axios parameter creator
 * @export
 */
export const ApiV1PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete multiple pipelines by IDs
         * @param {PipelineControllerBatchDeletePipelinesRequest} pipelineControllerBatchDeletePipelinesRequest Array of pipeline IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerBatchDeletePipelines: async (pipelineControllerBatchDeletePipelinesRequest: PipelineControllerBatchDeletePipelinesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineControllerBatchDeletePipelinesRequest' is not null or undefined
            assertParamExists('pipelineControllerBatchDeletePipelines', 'pipelineControllerBatchDeletePipelinesRequest', pipelineControllerBatchDeletePipelinesRequest)
            const localVarPath = `/api/v1/pipelines/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineControllerBatchDeletePipelinesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new pipeline
         * @param {PipelineCreateDto} pipelineCreateDto Pipeline data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerCreatePipeline: async (pipelineCreateDto: PipelineCreateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineCreateDto' is not null or undefined
            assertParamExists('pipelineControllerCreatePipeline', 'pipelineCreateDto', pipelineCreateDto)
            const localVarPath = `/api/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a pipeline by ID
         * @param {string} id The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerDeletePipeline: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelineControllerDeletePipeline', 'id', id)
            const localVarPath = `/api/v1/pipelines/id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a pipeline by ID
         * @param {string} id The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerGetPipelineById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelineControllerGetPipelineById', 'id', id)
            const localVarPath = `/api/v1/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve pipelines with filters, sorting, pagination, and search
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of PipelineFilterDto object
         * @param {string} [sortBy] JSON string array of PipelineSortByDto objects
         * @param {string} [search] Search term to filter workspaces by title or other searchable fields
         * @param {string} [searchColumns] JSON string array of columns to search in (defaults to title and type if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerGetPipelines: async (page?: number, limit?: number, filter?: string, sortBy?: string, search?: string, searchColumns?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/pipelines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (searchColumns !== undefined) {
                localVarQueryParameter['searchColumns'] = searchColumns;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a pipeline by ID
         * @param {string} id The ID of the pipeline
         * @param {PipelineUpdateDto} pipelineUpdateDto Updated pipeline data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerUpdatePipeline: async (id: string, pipelineUpdateDto: PipelineUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pipelineControllerUpdatePipeline', 'id', id)
            // verify required parameter 'pipelineUpdateDto' is not null or undefined
            assertParamExists('pipelineControllerUpdatePipeline', 'pipelineUpdateDto', pipelineUpdateDto)
            const localVarPath = `/api/v1/pipelines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pipelineUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1PipelinesApi - functional programming interface
 * @export
 */
export const ApiV1PipelinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1PipelinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete multiple pipelines by IDs
         * @param {PipelineControllerBatchDeletePipelinesRequest} pipelineControllerBatchDeletePipelinesRequest Array of pipeline IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineControllerBatchDeletePipelines(pipelineControllerBatchDeletePipelinesRequest: PipelineControllerBatchDeletePipelinesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineControllerBatchDeletePipelines200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerBatchDeletePipelines(pipelineControllerBatchDeletePipelinesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1PipelinesApi.pipelineControllerBatchDeletePipelines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new pipeline
         * @param {PipelineCreateDto} pipelineCreateDto Pipeline data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineControllerCreatePipeline(pipelineCreateDto: PipelineCreateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerCreatePipeline(pipelineCreateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1PipelinesApi.pipelineControllerCreatePipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a pipeline by ID
         * @param {string} id The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineControllerDeletePipeline(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerDeletePipeline(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1PipelinesApi.pipelineControllerDeletePipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a pipeline by ID
         * @param {string} id The ID of the pipeline
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineControllerGetPipelineById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerGetPipelineById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1PipelinesApi.pipelineControllerGetPipelineById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve pipelines with filters, sorting, pagination, and search
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of PipelineFilterDto object
         * @param {string} [sortBy] JSON string array of PipelineSortByDto objects
         * @param {string} [search] Search term to filter workspaces by title or other searchable fields
         * @param {string} [searchColumns] JSON string array of columns to search in (defaults to title and type if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineControllerGetPipelines(page?: number, limit?: number, filter?: string, sortBy?: string, search?: string, searchColumns?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineControllerGetPipelines200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerGetPipelines(page, limit, filter, sortBy, search, searchColumns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1PipelinesApi.pipelineControllerGetPipelines']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a pipeline by ID
         * @param {string} id The ID of the pipeline
         * @param {PipelineUpdateDto} pipelineUpdateDto Updated pipeline data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pipelineControllerUpdatePipeline(id: string, pipelineUpdateDto: PipelineUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerUpdatePipeline(id, pipelineUpdateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1PipelinesApi.pipelineControllerUpdatePipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1PipelinesApi - factory interface
 * @export
 */
export const ApiV1PipelinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1PipelinesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete multiple pipelines by IDs
         * @param {ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerBatchDeletePipelines(requestParameters: ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineControllerBatchDeletePipelines200Response> {
            return localVarFp.pipelineControllerBatchDeletePipelines(requestParameters.pipelineControllerBatchDeletePipelinesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new pipeline
         * @param {ApiV1PipelinesApiPipelineControllerCreatePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerCreatePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerCreatePipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto> {
            return localVarFp.pipelineControllerCreatePipeline(requestParameters.pipelineCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a pipeline by ID
         * @param {ApiV1PipelinesApiPipelineControllerDeletePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerDeletePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerDeletePipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pipelineControllerDeletePipeline(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a pipeline by ID
         * @param {ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerGetPipelineById(requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto> {
            return localVarFp.pipelineControllerGetPipelineById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve pipelines with filters, sorting, pagination, and search
         * @param {ApiV1PipelinesApiPipelineControllerGetPipelinesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerGetPipelines(requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelinesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PipelineControllerGetPipelines200Response> {
            return localVarFp.pipelineControllerGetPipelines(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, requestParameters.search, requestParameters.searchColumns, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a pipeline by ID
         * @param {ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pipelineControllerUpdatePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto> {
            return localVarFp.pipelineControllerUpdatePipeline(requestParameters.id, requestParameters.pipelineUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1PipelinesApi - interface
 * @export
 * @interface ApiV1PipelinesApi
 */
export interface ApiV1PipelinesApiInterface {
    /**
     * 
     * @summary Delete multiple pipelines by IDs
     * @param {ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApiInterface
     */
    pipelineControllerBatchDeletePipelines(requestParameters: ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineControllerBatchDeletePipelines200Response>;

    /**
     * 
     * @summary Create a new pipeline
     * @param {ApiV1PipelinesApiPipelineControllerCreatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApiInterface
     */
    pipelineControllerCreatePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerCreatePipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto>;

    /**
     * 
     * @summary Delete a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerDeletePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApiInterface
     */
    pipelineControllerDeletePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerDeletePipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApiInterface
     */
    pipelineControllerGetPipelineById(requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto>;

    /**
     * 
     * @summary Retrieve pipelines with filters, sorting, pagination, and search
     * @param {ApiV1PipelinesApiPipelineControllerGetPipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApiInterface
     */
    pipelineControllerGetPipelines(requestParameters?: ApiV1PipelinesApiPipelineControllerGetPipelinesRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineControllerGetPipelines200Response>;

    /**
     * 
     * @summary Update a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApiInterface
     */
    pipelineControllerUpdatePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<PipelineDto>;

}

/**
 * Request parameters for pipelineControllerBatchDeletePipelines operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest
 */
export interface ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest {
    /**
     * Array of pipeline IDs to delete
     * @type {PipelineControllerBatchDeletePipelinesRequest}
     * @memberof ApiV1PipelinesApiPipelineControllerBatchDeletePipelines
     */
    readonly pipelineControllerBatchDeletePipelinesRequest: PipelineControllerBatchDeletePipelinesRequest
}

/**
 * Request parameters for pipelineControllerCreatePipeline operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerCreatePipelineRequest
 */
export interface ApiV1PipelinesApiPipelineControllerCreatePipelineRequest {
    /**
     * Pipeline data
     * @type {PipelineCreateDto}
     * @memberof ApiV1PipelinesApiPipelineControllerCreatePipeline
     */
    readonly pipelineCreateDto: PipelineCreateDto
}

/**
 * Request parameters for pipelineControllerDeletePipeline operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerDeletePipelineRequest
 */
export interface ApiV1PipelinesApiPipelineControllerDeletePipelineRequest {
    /**
     * The ID of the pipeline
     * @type {string}
     * @memberof ApiV1PipelinesApiPipelineControllerDeletePipeline
     */
    readonly id: string
}

/**
 * Request parameters for pipelineControllerGetPipelineById operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest
 */
export interface ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest {
    /**
     * The ID of the pipeline
     * @type {string}
     * @memberof ApiV1PipelinesApiPipelineControllerGetPipelineById
     */
    readonly id: string
}

/**
 * Request parameters for pipelineControllerGetPipelines operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerGetPipelinesRequest
 */
export interface ApiV1PipelinesApiPipelineControllerGetPipelinesRequest {
    /**
     * Page number for pagination (starts at 1)
     * @type {number}
     * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
     */
    readonly limit?: number

    /**
     * JSON string of PipelineFilterDto object
     * @type {string}
     * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
     */
    readonly filter?: string

    /**
     * JSON string array of PipelineSortByDto objects
     * @type {string}
     * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
     */
    readonly sortBy?: string

    /**
     * Search term to filter workspaces by title or other searchable fields
     * @type {string}
     * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
     */
    readonly search?: string

    /**
     * JSON string array of columns to search in (defaults to title and type if not specified)
     * @type {string}
     * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
     */
    readonly searchColumns?: string
}

/**
 * Request parameters for pipelineControllerUpdatePipeline operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest
 */
export interface ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest {
    /**
     * The ID of the pipeline
     * @type {string}
     * @memberof ApiV1PipelinesApiPipelineControllerUpdatePipeline
     */
    readonly id: string

    /**
     * Updated pipeline data
     * @type {PipelineUpdateDto}
     * @memberof ApiV1PipelinesApiPipelineControllerUpdatePipeline
     */
    readonly pipelineUpdateDto: PipelineUpdateDto
}

/**
 * ApiV1PipelinesApi - object-oriented interface
 * @export
 * @class ApiV1PipelinesApi
 * @extends {BaseAPI}
 */
export class ApiV1PipelinesApi extends BaseAPI implements ApiV1PipelinesApiInterface {
    /**
     * 
     * @summary Delete multiple pipelines by IDs
     * @param {ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApi
     */
    public pipelineControllerBatchDeletePipelines(requestParameters: ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest, options?: RawAxiosRequestConfig) {
        return ApiV1PipelinesApiFp(this.configuration).pipelineControllerBatchDeletePipelines(requestParameters.pipelineControllerBatchDeletePipelinesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new pipeline
     * @param {ApiV1PipelinesApiPipelineControllerCreatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApi
     */
    public pipelineControllerCreatePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerCreatePipelineRequest, options?: RawAxiosRequestConfig) {
        return ApiV1PipelinesApiFp(this.configuration).pipelineControllerCreatePipeline(requestParameters.pipelineCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerDeletePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApi
     */
    public pipelineControllerDeletePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerDeletePipelineRequest, options?: RawAxiosRequestConfig) {
        return ApiV1PipelinesApiFp(this.configuration).pipelineControllerDeletePipeline(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApi
     */
    public pipelineControllerGetPipelineById(requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest, options?: RawAxiosRequestConfig) {
        return ApiV1PipelinesApiFp(this.configuration).pipelineControllerGetPipelineById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve pipelines with filters, sorting, pagination, and search
     * @param {ApiV1PipelinesApiPipelineControllerGetPipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApi
     */
    public pipelineControllerGetPipelines(requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelinesRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiV1PipelinesApiFp(this.configuration).pipelineControllerGetPipelines(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, requestParameters.search, requestParameters.searchColumns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1PipelinesApi
     */
    public pipelineControllerUpdatePipeline(requestParameters: ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest, options?: RawAxiosRequestConfig) {
        return ApiV1PipelinesApiFp(this.configuration).pipelineControllerUpdatePipeline(requestParameters.id, requestParameters.pipelineUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1ProcessorApi - axios parameter creator
 * @export
 */
export const ApiV1ProcessorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers the processing of a pipeline with the given ID and configuration
         * @summary Run a pipeline
         * @param {string} pipelineId The unique identifier of the pipeline to run
         * @param {RunPipelinePayloadDto} runPipelinePayloadDto Configuration and parameters for the pipeline run
         * @param {boolean} [force] When true, forces the pipeline to run even if locked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processorControllerRunPipeline: async (pipelineId: string, runPipelinePayloadDto: RunPipelinePayloadDto, force?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipelineId' is not null or undefined
            assertParamExists('processorControllerRunPipeline', 'pipelineId', pipelineId)
            // verify required parameter 'runPipelinePayloadDto' is not null or undefined
            assertParamExists('processorControllerRunPipeline', 'runPipelinePayloadDto', runPipelinePayloadDto)
            const localVarPath = `/api/v1/processor/run/{pipelineId}`
                .replace(`{${"pipelineId"}}`, encodeURIComponent(String(pipelineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runPipelinePayloadDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1ProcessorApi - functional programming interface
 * @export
 */
export const ApiV1ProcessorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1ProcessorApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers the processing of a pipeline with the given ID and configuration
         * @summary Run a pipeline
         * @param {string} pipelineId The unique identifier of the pipeline to run
         * @param {RunPipelinePayloadDto} runPipelinePayloadDto Configuration and parameters for the pipeline run
         * @param {boolean} [force] When true, forces the pipeline to run even if locked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processorControllerRunPipeline(pipelineId: string, runPipelinePayloadDto: RunPipelinePayloadDto, force?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processorControllerRunPipeline(pipelineId, runPipelinePayloadDto, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1ProcessorApi.processorControllerRunPipeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1ProcessorApi - factory interface
 * @export
 */
export const ApiV1ProcessorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1ProcessorApiFp(configuration)
    return {
        /**
         * Triggers the processing of a pipeline with the given ID and configuration
         * @summary Run a pipeline
         * @param {ApiV1ProcessorApiProcessorControllerRunPipelineRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processorControllerRunPipeline(requestParameters: ApiV1ProcessorApiProcessorControllerRunPipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.processorControllerRunPipeline(requestParameters.pipelineId, requestParameters.runPipelinePayloadDto, requestParameters.force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1ProcessorApi - interface
 * @export
 * @interface ApiV1ProcessorApi
 */
export interface ApiV1ProcessorApiInterface {
    /**
     * Triggers the processing of a pipeline with the given ID and configuration
     * @summary Run a pipeline
     * @param {ApiV1ProcessorApiProcessorControllerRunPipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1ProcessorApiInterface
     */
    processorControllerRunPipeline(requestParameters: ApiV1ProcessorApiProcessorControllerRunPipelineRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for processorControllerRunPipeline operation in ApiV1ProcessorApi.
 * @export
 * @interface ApiV1ProcessorApiProcessorControllerRunPipelineRequest
 */
export interface ApiV1ProcessorApiProcessorControllerRunPipelineRequest {
    /**
     * The unique identifier of the pipeline to run
     * @type {string}
     * @memberof ApiV1ProcessorApiProcessorControllerRunPipeline
     */
    readonly pipelineId: string

    /**
     * Configuration and parameters for the pipeline run
     * @type {RunPipelinePayloadDto}
     * @memberof ApiV1ProcessorApiProcessorControllerRunPipeline
     */
    readonly runPipelinePayloadDto: RunPipelinePayloadDto

    /**
     * When true, forces the pipeline to run even if locked
     * @type {boolean}
     * @memberof ApiV1ProcessorApiProcessorControllerRunPipeline
     */
    readonly force?: boolean
}

/**
 * ApiV1ProcessorApi - object-oriented interface
 * @export
 * @class ApiV1ProcessorApi
 * @extends {BaseAPI}
 */
export class ApiV1ProcessorApi extends BaseAPI implements ApiV1ProcessorApiInterface {
    /**
     * Triggers the processing of a pipeline with the given ID and configuration
     * @summary Run a pipeline
     * @param {ApiV1ProcessorApiProcessorControllerRunPipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1ProcessorApi
     */
    public processorControllerRunPipeline(requestParameters: ApiV1ProcessorApiProcessorControllerRunPipelineRequest, options?: RawAxiosRequestConfig) {
        return ApiV1ProcessorApiFp(this.configuration).processorControllerRunPipeline(requestParameters.pipelineId, requestParameters.runPipelinePayloadDto, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1WorkflowsApi - axios parameter creator
 * @export
 */
export const ApiV1WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a workflow by ID
         * @param {string} id The ID of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowControllerDeleteWorkflow: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workflowControllerDeleteWorkflow', 'id', id)
            const localVarPath = `/api/v1/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a workflow by ID
         * @param {string} id The ID of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowControllerGetWorkflowById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workflowControllerGetWorkflowById', 'id', id)
            const localVarPath = `/api/v1/workflows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve workflows with filters, sorting, and pagination
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of WorkflowFilterDto object
         * @param {string} [sortBy] JSON string array of WorkflowSortByDto objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowControllerGetWorkflows: async (page?: number, limit?: number, filter?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1WorkflowsApi - functional programming interface
 * @export
 */
export const ApiV1WorkflowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1WorkflowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a workflow by ID
         * @param {string} id The ID of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowControllerDeleteWorkflow(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowControllerDeleteWorkflow(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkflowsApi.workflowControllerDeleteWorkflow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a workflow by ID
         * @param {string} id The ID of the workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowControllerGetWorkflowById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowControllerGetWorkflowById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkflowsApi.workflowControllerGetWorkflowById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve workflows with filters, sorting, and pagination
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of WorkflowFilterDto object
         * @param {string} [sortBy] JSON string array of WorkflowSortByDto objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowControllerGetWorkflows(page?: number, limit?: number, filter?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowControllerGetWorkflows200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowControllerGetWorkflows(page, limit, filter, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkflowsApi.workflowControllerGetWorkflows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1WorkflowsApi - factory interface
 * @export
 */
export const ApiV1WorkflowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1WorkflowsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a workflow by ID
         * @param {ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowControllerDeleteWorkflow(requestParameters: ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workflowControllerDeleteWorkflow(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a workflow by ID
         * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowControllerGetWorkflowById(requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowDto> {
            return localVarFp.workflowControllerGetWorkflowById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve workflows with filters, sorting, and pagination
         * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowControllerGetWorkflows(requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowControllerGetWorkflows200Response> {
            return localVarFp.workflowControllerGetWorkflows(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1WorkflowsApi - interface
 * @export
 * @interface ApiV1WorkflowsApi
 */
export interface ApiV1WorkflowsApiInterface {
    /**
     * 
     * @summary Delete a workflow by ID
     * @param {ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkflowsApiInterface
     */
    workflowControllerDeleteWorkflow(requestParameters: ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a workflow by ID
     * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkflowsApiInterface
     */
    workflowControllerGetWorkflowById(requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowDto>;

    /**
     * 
     * @summary Retrieve workflows with filters, sorting, and pagination
     * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkflowsApiInterface
     */
    workflowControllerGetWorkflows(requestParameters?: ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkflowControllerGetWorkflows200Response>;

}

/**
 * Request parameters for workflowControllerDeleteWorkflow operation in ApiV1WorkflowsApi.
 * @export
 * @interface ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest
 */
export interface ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest {
    /**
     * The ID of the workflow
     * @type {string}
     * @memberof ApiV1WorkflowsApiWorkflowControllerDeleteWorkflow
     */
    readonly id: string
}

/**
 * Request parameters for workflowControllerGetWorkflowById operation in ApiV1WorkflowsApi.
 * @export
 * @interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest
 */
export interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest {
    /**
     * The ID of the workflow
     * @type {string}
     * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflowById
     */
    readonly id: string
}

/**
 * Request parameters for workflowControllerGetWorkflows operation in ApiV1WorkflowsApi.
 * @export
 * @interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest
 */
export interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest {
    /**
     * Page number for pagination (starts at 1)
     * @type {number}
     * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
     */
    readonly limit?: number

    /**
     * JSON string of WorkflowFilterDto object
     * @type {string}
     * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
     */
    readonly filter?: string

    /**
     * JSON string array of WorkflowSortByDto objects
     * @type {string}
     * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
     */
    readonly sortBy?: string
}

/**
 * ApiV1WorkflowsApi - object-oriented interface
 * @export
 * @class ApiV1WorkflowsApi
 * @extends {BaseAPI}
 */
export class ApiV1WorkflowsApi extends BaseAPI implements ApiV1WorkflowsApiInterface {
    /**
     * 
     * @summary Delete a workflow by ID
     * @param {ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkflowsApi
     */
    public workflowControllerDeleteWorkflow(requestParameters: ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest, options?: RawAxiosRequestConfig) {
        return ApiV1WorkflowsApiFp(this.configuration).workflowControllerDeleteWorkflow(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a workflow by ID
     * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkflowsApi
     */
    public workflowControllerGetWorkflowById(requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest, options?: RawAxiosRequestConfig) {
        return ApiV1WorkflowsApiFp(this.configuration).workflowControllerGetWorkflowById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve workflows with filters, sorting, and pagination
     * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkflowsApi
     */
    public workflowControllerGetWorkflows(requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiV1WorkflowsApiFp(this.configuration).workflowControllerGetWorkflows(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiV1WorkspacesApi - axios parameter creator
 * @export
 */
export const ApiV1WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete multiple workspaces by IDs
         * @param {WorkspaceControllerBatchDeleteWorkspacesRequest} workspaceControllerBatchDeleteWorkspacesRequest Array of workspace IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerBatchDeleteWorkspaces: async (workspaceControllerBatchDeleteWorkspacesRequest: WorkspaceControllerBatchDeleteWorkspacesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceControllerBatchDeleteWorkspacesRequest' is not null or undefined
            assertParamExists('workspaceControllerBatchDeleteWorkspaces', 'workspaceControllerBatchDeleteWorkspacesRequest', workspaceControllerBatchDeleteWorkspacesRequest)
            const localVarPath = `/api/v1/workspaces/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceControllerBatchDeleteWorkspacesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {WorkspaceCreateDto} workspaceCreateDto Workspace data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerCreateWorkspace: async (workspaceCreateDto: WorkspaceCreateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceCreateDto' is not null or undefined
            assertParamExists('workspaceControllerCreateWorkspace', 'workspaceCreateDto', workspaceCreateDto)
            const localVarPath = `/api/v1/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace by ID
         * @param {string} id The ID of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerDeleteWorkspace: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceControllerDeleteWorkspace', 'id', id)
            const localVarPath = `/api/v1/workspaces/id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a workspace by ID
         * @param {string} id The ID of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerGetWorkspaceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceControllerGetWorkspaceById', 'id', id)
            const localVarPath = `/api/v1/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve workspaces with filters, sorting, pagination, and search
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of WorkspaceFilterDto object
         * @param {string} [sortBy] JSON string array of WorkspaceSortByDto objects
         * @param {string} [search] Search term to filter workspaces by title or other searchable fields
         * @param {string} [searchColumns] JSON string array of columns to search in (defaults to title and type if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerGetWorkspaces: async (page?: number, limit?: number, filter?: string, sortBy?: string, search?: string, searchColumns?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/workspaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (searchColumns !== undefined) {
                localVarQueryParameter['searchColumns'] = searchColumns;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace by ID
         * @param {string} id The ID of the workspace
         * @param {WorkspaceUpdateDto} workspaceUpdateDto Updated workspace data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerUpdateWorkspace: async (id: string, workspaceUpdateDto: WorkspaceUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('workspaceControllerUpdateWorkspace', 'id', id)
            // verify required parameter 'workspaceUpdateDto' is not null or undefined
            assertParamExists('workspaceControllerUpdateWorkspace', 'workspaceUpdateDto', workspaceUpdateDto)
            const localVarPath = `/api/v1/workspaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiV1WorkspacesApi - functional programming interface
 * @export
 */
export const ApiV1WorkspacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiV1WorkspacesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete multiple workspaces by IDs
         * @param {WorkspaceControllerBatchDeleteWorkspacesRequest} workspaceControllerBatchDeleteWorkspacesRequest Array of workspace IDs to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceControllerBatchDeleteWorkspaces(workspaceControllerBatchDeleteWorkspacesRequest: WorkspaceControllerBatchDeleteWorkspacesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceControllerBatchDeleteWorkspaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerBatchDeleteWorkspaces(workspaceControllerBatchDeleteWorkspacesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkspacesApi.workspaceControllerBatchDeleteWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {WorkspaceCreateDto} workspaceCreateDto Workspace data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceControllerCreateWorkspace(workspaceCreateDto: WorkspaceCreateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerCreateWorkspace(workspaceCreateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkspacesApi.workspaceControllerCreateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace by ID
         * @param {string} id The ID of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceControllerDeleteWorkspace(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerDeleteWorkspace(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkspacesApi.workspaceControllerDeleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a workspace by ID
         * @param {string} id The ID of the workspace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceControllerGetWorkspaceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerGetWorkspaceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkspacesApi.workspaceControllerGetWorkspaceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve workspaces with filters, sorting, pagination, and search
         * @param {number} [page] Page number for pagination (starts at 1)
         * @param {number} [limit] Number of items per page
         * @param {string} [filter] JSON string of WorkspaceFilterDto object
         * @param {string} [sortBy] JSON string array of WorkspaceSortByDto objects
         * @param {string} [search] Search term to filter workspaces by title or other searchable fields
         * @param {string} [searchColumns] JSON string array of columns to search in (defaults to title and type if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceControllerGetWorkspaces(page?: number, limit?: number, filter?: string, sortBy?: string, search?: string, searchColumns?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceControllerGetWorkspaces200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerGetWorkspaces(page, limit, filter, sortBy, search, searchColumns, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkspacesApi.workspaceControllerGetWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workspace by ID
         * @param {string} id The ID of the workspace
         * @param {WorkspaceUpdateDto} workspaceUpdateDto Updated workspace data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workspaceControllerUpdateWorkspace(id: string, workspaceUpdateDto: WorkspaceUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerUpdateWorkspace(id, workspaceUpdateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiV1WorkspacesApi.workspaceControllerUpdateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiV1WorkspacesApi - factory interface
 * @export
 */
export const ApiV1WorkspacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiV1WorkspacesApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete multiple workspaces by IDs
         * @param {ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerBatchDeleteWorkspaces(requestParameters: ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceControllerBatchDeleteWorkspaces200Response> {
            return localVarFp.workspaceControllerBatchDeleteWorkspaces(requestParameters.workspaceControllerBatchDeleteWorkspacesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerCreateWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceDto> {
            return localVarFp.workspaceControllerCreateWorkspace(requestParameters.workspaceCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace by ID
         * @param {ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerDeleteWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.workspaceControllerDeleteWorkspace(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a workspace by ID
         * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerGetWorkspaceById(requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceDto> {
            return localVarFp.workspaceControllerGetWorkspaceById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve workspaces with filters, sorting, pagination, and search
         * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerGetWorkspaces(requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceControllerGetWorkspaces200Response> {
            return localVarFp.workspaceControllerGetWorkspaces(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, requestParameters.search, requestParameters.searchColumns, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace by ID
         * @param {ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workspaceControllerUpdateWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceDto> {
            return localVarFp.workspaceControllerUpdateWorkspace(requestParameters.id, requestParameters.workspaceUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiV1WorkspacesApi - interface
 * @export
 * @interface ApiV1WorkspacesApi
 */
export interface ApiV1WorkspacesApiInterface {
    /**
     * 
     * @summary Delete multiple workspaces by IDs
     * @param {ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApiInterface
     */
    workspaceControllerBatchDeleteWorkspaces(requestParameters: ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceControllerBatchDeleteWorkspaces200Response>;

    /**
     * 
     * @summary Create a new workspace
     * @param {ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApiInterface
     */
    workspaceControllerCreateWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceDto>;

    /**
     * 
     * @summary Delete a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApiInterface
     */
    workspaceControllerDeleteWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApiInterface
     */
    workspaceControllerGetWorkspaceById(requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceDto>;

    /**
     * 
     * @summary Retrieve workspaces with filters, sorting, pagination, and search
     * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApiInterface
     */
    workspaceControllerGetWorkspaces(requestParameters?: ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceControllerGetWorkspaces200Response>;

    /**
     * 
     * @summary Update a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApiInterface
     */
    workspaceControllerUpdateWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceDto>;

}

/**
 * Request parameters for workspaceControllerBatchDeleteWorkspaces operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest {
    /**
     * Array of workspace IDs to delete
     * @type {WorkspaceControllerBatchDeleteWorkspacesRequest}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspaces
     */
    readonly workspaceControllerBatchDeleteWorkspacesRequest: WorkspaceControllerBatchDeleteWorkspacesRequest
}

/**
 * Request parameters for workspaceControllerCreateWorkspace operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest {
    /**
     * Workspace data
     * @type {WorkspaceCreateDto}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerCreateWorkspace
     */
    readonly workspaceCreateDto: WorkspaceCreateDto
}

/**
 * Request parameters for workspaceControllerDeleteWorkspace operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest {
    /**
     * The ID of the workspace
     * @type {string}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspace
     */
    readonly id: string
}

/**
 * Request parameters for workspaceControllerGetWorkspaceById operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest {
    /**
     * The ID of the workspace
     * @type {string}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceById
     */
    readonly id: string
}

/**
 * Request parameters for workspaceControllerGetWorkspaces operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest {
    /**
     * Page number for pagination (starts at 1)
     * @type {number}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
     */
    readonly page?: number

    /**
     * Number of items per page
     * @type {number}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
     */
    readonly limit?: number

    /**
     * JSON string of WorkspaceFilterDto object
     * @type {string}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
     */
    readonly filter?: string

    /**
     * JSON string array of WorkspaceSortByDto objects
     * @type {string}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
     */
    readonly sortBy?: string

    /**
     * Search term to filter workspaces by title or other searchable fields
     * @type {string}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
     */
    readonly search?: string

    /**
     * JSON string array of columns to search in (defaults to title and type if not specified)
     * @type {string}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
     */
    readonly searchColumns?: string
}

/**
 * Request parameters for workspaceControllerUpdateWorkspace operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest {
    /**
     * The ID of the workspace
     * @type {string}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspace
     */
    readonly id: string

    /**
     * Updated workspace data
     * @type {WorkspaceUpdateDto}
     * @memberof ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspace
     */
    readonly workspaceUpdateDto: WorkspaceUpdateDto
}

/**
 * ApiV1WorkspacesApi - object-oriented interface
 * @export
 * @class ApiV1WorkspacesApi
 * @extends {BaseAPI}
 */
export class ApiV1WorkspacesApi extends BaseAPI implements ApiV1WorkspacesApiInterface {
    /**
     * 
     * @summary Delete multiple workspaces by IDs
     * @param {ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApi
     */
    public workspaceControllerBatchDeleteWorkspaces(requestParameters: ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest, options?: RawAxiosRequestConfig) {
        return ApiV1WorkspacesApiFp(this.configuration).workspaceControllerBatchDeleteWorkspaces(requestParameters.workspaceControllerBatchDeleteWorkspacesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workspace
     * @param {ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApi
     */
    public workspaceControllerCreateWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return ApiV1WorkspacesApiFp(this.configuration).workspaceControllerCreateWorkspace(requestParameters.workspaceCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApi
     */
    public workspaceControllerDeleteWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return ApiV1WorkspacesApiFp(this.configuration).workspaceControllerDeleteWorkspace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApi
     */
    public workspaceControllerGetWorkspaceById(requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest, options?: RawAxiosRequestConfig) {
        return ApiV1WorkspacesApiFp(this.configuration).workspaceControllerGetWorkspaceById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve workspaces with filters, sorting, pagination, and search
     * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApi
     */
    public workspaceControllerGetWorkspaces(requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiV1WorkspacesApiFp(this.configuration).workspaceControllerGetWorkspaces(requestParameters.page, requestParameters.limit, requestParameters.filter, requestParameters.sortBy, requestParameters.search, requestParameters.searchColumns, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiV1WorkspacesApi
     */
    public workspaceControllerUpdateWorkspace(requestParameters: ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return ApiV1WorkspacesApiFp(this.configuration).workspaceControllerUpdateWorkspace(requestParameters.id, requestParameters.workspaceUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



