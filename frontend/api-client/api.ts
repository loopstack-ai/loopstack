/* tslint:disable */
/* eslint-disable */
/**
 * Loopstack API Documentation
 * Loopstack API Documentation
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequiredError, operationServerMap } from './base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from './common';
import type { Configuration } from './configuration';

/**
 *
 * @export
 * @interface AdminRoleCreateDto
 */
export interface AdminRoleCreateDto {
  /**
   * Unique role name
   * @type {string}
   * @memberof AdminRoleCreateDto
   */
  name: string;
  /**
   * Human-readable description of the role
   * @type {string}
   * @memberof AdminRoleCreateDto
   */
  description?: string;
}
/**
 *
 * @export
 * @interface AdminRoleDto
 */
export interface AdminRoleDto {
  /**
   * Unique identifier of the role
   * @type {string}
   * @memberof AdminRoleDto
   */
  id: string;
  /**
   * Role name
   * @type {string}
   * @memberof AdminRoleDto
   */
  name: string;
  /**
   * Human-readable description
   * @type {string}
   * @memberof AdminRoleDto
   */
  description?: string;
  /**
   * Number of users assigned to this role
   * @type {number}
   * @memberof AdminRoleDto
   */
  userCount?: number;
}
/**
 *
 * @export
 * @interface AdminRoleItemDto
 */
export interface AdminRoleItemDto {
  /**
   * Unique identifier of the role
   * @type {string}
   * @memberof AdminRoleItemDto
   */
  id: string;
  /**
   * Role name
   * @type {string}
   * @memberof AdminRoleItemDto
   */
  name: string;
  /**
   * Human-readable description
   * @type {string}
   * @memberof AdminRoleItemDto
   */
  description?: string;
  /**
   * Number of users assigned to this role
   * @type {number}
   * @memberof AdminRoleItemDto
   */
  userCount: number;
}
/**
 *
 * @export
 * @interface AdminRoleUpdateDto
 */
export interface AdminRoleUpdateDto {
  /**
   * Unique role name
   * @type {string}
   * @memberof AdminRoleUpdateDto
   */
  name?: string;
  /**
   * Human-readable description of the role
   * @type {string}
   * @memberof AdminRoleUpdateDto
   */
  description?: string;
}
/**
 *
 * @export
 * @interface AdminUserAssignRolesDto
 */
export interface AdminUserAssignRolesDto {
  /**
   * Array of role UUIDs to assign to the user (replaces existing roles)
   * @type {Array<string>}
   * @memberof AdminUserAssignRolesDto
   */
  roleIds: Array<string>;
}
/**
 *
 * @export
 * @interface AdminUserControllerGetUsers200Response
 */
export interface AdminUserControllerGetUsers200Response {
  /**
   *
   * @type {Array<AdminUserItemDto>}
   * @memberof AdminUserControllerGetUsers200Response
   */
  data: Array<AdminUserItemDto>;
  /**
   *
   * @type {number}
   * @memberof AdminUserControllerGetUsers200Response
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof AdminUserControllerGetUsers200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof AdminUserControllerGetUsers200Response
   */
  limit: number;
}
/**
 *
 * @export
 * @interface AdminUserDto
 */
export interface AdminUserDto {
  /**
   * Unique identifier of the user
   * @type {string}
   * @memberof AdminUserDto
   */
  id: string;
  /**
   * Type of user account
   * @type {string}
   * @memberof AdminUserDto
   */
  type: AdminUserDtoTypeEnum;
  /**
   * Whether the user account is active
   * @type {boolean}
   * @memberof AdminUserDto
   */
  isActive: boolean;
  /**
   * Roles assigned to this user
   * @type {Array<AdminRoleDto>}
   * @memberof AdminUserDto
   */
  roles: Array<AdminRoleDto>;
  /**
   * Timestamp when the user was created
   * @type {string}
   * @memberof AdminUserDto
   */
  createdAt: string;
  /**
   * Timestamp when the user was last updated
   * @type {string}
   * @memberof AdminUserDto
   */
  updatedAt: string;
}

export const AdminUserDtoTypeEnum = {
  Local: 'local',
  Cloud: 'cloud',
} as const;

export type AdminUserDtoTypeEnum = (typeof AdminUserDtoTypeEnum)[keyof typeof AdminUserDtoTypeEnum];

/**
 *
 * @export
 * @interface AdminUserFilterDto
 */
export interface AdminUserFilterDto {
  /**
   *
   * @type {string}
   * @memberof AdminUserFilterDto
   */
  type?: AdminUserFilterDtoTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof AdminUserFilterDto
   */
  isActive?: boolean;
}

export const AdminUserFilterDtoTypeEnum = {
  Local: 'local',
  Cloud: 'cloud',
} as const;

export type AdminUserFilterDtoTypeEnum = (typeof AdminUserFilterDtoTypeEnum)[keyof typeof AdminUserFilterDtoTypeEnum];

/**
 *
 * @export
 * @interface AdminUserItemDto
 */
export interface AdminUserItemDto {
  /**
   * Unique identifier of the user
   * @type {string}
   * @memberof AdminUserItemDto
   */
  id: string;
  /**
   * Type of user account
   * @type {string}
   * @memberof AdminUserItemDto
   */
  type: AdminUserItemDtoTypeEnum;
  /**
   * Whether the user account is active
   * @type {boolean}
   * @memberof AdminUserItemDto
   */
  isActive: boolean;
  /**
   * Role names assigned to this user
   * @type {Array<string>}
   * @memberof AdminUserItemDto
   */
  roleNames: Array<string>;
  /**
   * Timestamp when the user was created
   * @type {string}
   * @memberof AdminUserItemDto
   */
  createdAt: string;
  /**
   * Timestamp when the user was last updated
   * @type {string}
   * @memberof AdminUserItemDto
   */
  updatedAt: string;
}

export const AdminUserItemDtoTypeEnum = {
  Local: 'local',
  Cloud: 'cloud',
} as const;

export type AdminUserItemDtoTypeEnum = (typeof AdminUserItemDtoTypeEnum)[keyof typeof AdminUserItemDtoTypeEnum];

/**
 *
 * @export
 * @interface AdminUserSortByDto
 */
export interface AdminUserSortByDto {
  /**
   *
   * @type {string}
   * @memberof AdminUserSortByDto
   */
  field: AdminUserSortByDtoFieldEnum;
  /**
   *
   * @type {string}
   * @memberof AdminUserSortByDto
   */
  order: AdminUserSortByDtoOrderEnum;
}

export const AdminUserSortByDtoFieldEnum = {
  Id: 'id',
  Type: 'type',
  IsActive: 'isActive',
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
} as const;

export type AdminUserSortByDtoFieldEnum =
  (typeof AdminUserSortByDtoFieldEnum)[keyof typeof AdminUserSortByDtoFieldEnum];
export const AdminUserSortByDtoOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type AdminUserSortByDtoOrderEnum =
  (typeof AdminUserSortByDtoOrderEnum)[keyof typeof AdminUserSortByDtoOrderEnum];

/**
 *
 * @export
 * @interface AdminUserUpdateStatusDto
 */
export interface AdminUserUpdateStatusDto {
  /**
   * Whether the user account should be active
   * @type {boolean}
   * @memberof AdminUserUpdateStatusDto
   */
  isActive: boolean;
}
/**
 *
 * @export
 * @interface DashboardStatsDto
 */
export interface DashboardStatsDto {
  /**
   * Total number of workspaces
   * @type {number}
   * @memberof DashboardStatsDto
   */
  workspaceCount: number;
  /**
   * Total number of automations
   * @type {number}
   * @memberof DashboardStatsDto
   */
  totalAutomations: number;
  /**
   * Total number of automation runs
   * @type {number}
   * @memberof DashboardStatsDto
   */
  totalAutomationRuns: number;
  /**
   * Number of completed runs
   * @type {number}
   * @memberof DashboardStatsDto
   */
  completedRuns: number;
  /**
   * Number of runs with errors
   * @type {number}
   * @memberof DashboardStatsDto
   */
  errorRuns: number;
  /**
   * Number of runs currently in progress
   * @type {number}
   * @memberof DashboardStatsDto
   */
  inProgressRuns: number;
  /**
   * List of recent workflow errors
   * @type {Array<WorkflowDto>}
   * @memberof DashboardStatsDto
   */
  recentErrors: Array<WorkflowDto>;
  /**
   * List of recent pipeline runs
   * @type {Array<PipelineDto>}
   * @memberof DashboardStatsDto
   */
  recentRuns: Array<PipelineDto>;
}
/**
 *
 * @export
 * @interface DocumentControllerGetDocuments200Response
 */
export interface DocumentControllerGetDocuments200Response {
  /**
   *
   * @type {Array<DocumentItemDto>}
   * @memberof DocumentControllerGetDocuments200Response
   */
  data: Array<DocumentItemDto>;
  /**
   *
   * @type {number}
   * @memberof DocumentControllerGetDocuments200Response
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof DocumentControllerGetDocuments200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof DocumentControllerGetDocuments200Response
   */
  limit: number;
}
/**
 *
 * @export
 * @interface DocumentDto
 */
export interface DocumentDto {
  /**
   * Unique identifier of the document
   * @type {string}
   * @memberof DocumentDto
   */
  id: string;
  /**
   * Name of the document
   * @type {string}
   * @memberof DocumentDto
   */
  name: string;
  /**
   * Config key of the document
   * @type {string}
   * @memberof DocumentDto
   */
  blockName: string;
  /**
   * Contents of the document
   * @type {object}
   * @memberof DocumentDto
   */
  content: object;
  /**
   * The json schema for form validation
   * @type {object}
   * @memberof DocumentDto
   */
  schema: object;
  /**
   * The zod validation error or null
   * @type {object}
   * @memberof DocumentDto
   */
  validationError: object;
  /**
   * The ui config for interface rendering
   * @type {object}
   * @memberof DocumentDto
   */
  ui: object;
  /**
   * Document metadata
   * @type {object}
   * @memberof DocumentDto
   */
  meta: object;
  /**
   * Indicates if the document is invalidated
   * @type {boolean}
   * @memberof DocumentDto
   */
  isInvalidated: boolean;
  /**
   * Indicates if the document is pending removal
   * @type {boolean}
   * @memberof DocumentDto
   */
  isPendingRemoval: boolean;
  /**
   * Index of the document in the workflow
   * @type {number}
   * @memberof DocumentDto
   */
  workflowIndex: number;
  /**
   * Version of the document
   * @type {number}
   * @memberof DocumentDto
   */
  version: number;
  /**
   * Index of the document
   * @type {number}
   * @memberof DocumentDto
   */
  index: number;
  /**
   * Transition when this document was created
   * @type {object}
   * @memberof DocumentDto
   */
  transition: object;
  /**
   * Place when this document was created
   * @type {object}
   * @memberof DocumentDto
   */
  place: object;
  /**
   * Labels associated with the document\'s namespace
   * @type {Array<string>}
   * @memberof DocumentDto
   */
  labels: Array<string>;
  /**
   * Tags associated with the document for categorization and filtering
   * @type {Array<string>}
   * @memberof DocumentDto
   */
  tags: Array<string>;
  /**
   * Date when the document was created
   * @type {string}
   * @memberof DocumentDto
   */
  createdAt: string;
  /**
   * Date when the document was last updated
   * @type {string}
   * @memberof DocumentDto
   */
  updatedAt: string;
  /**
   * ID of the workspace the document belongs to
   * @type {string}
   * @memberof DocumentDto
   */
  workspaceId: string;
  /**
   * ID of the pipeline the document belongs to
   * @type {string}
   * @memberof DocumentDto
   */
  pipelineId: string;
  /**
   * ID of the workflow the document belongs to
   * @type {string}
   * @memberof DocumentDto
   */
  workflowId: string;
}
/**
 *
 * @export
 * @interface DocumentFilterDto
 */
export interface DocumentFilterDto {
  /**
   *
   * @type {string}
   * @memberof DocumentFilterDto
   */
  workflowId?: string;
}
/**
 *
 * @export
 * @interface DocumentItemDto
 */
export interface DocumentItemDto {
  /**
   * Unique identifier of the document
   * @type {string}
   * @memberof DocumentItemDto
   */
  id: string;
  /**
   * Name of the document
   * @type {string}
   * @memberof DocumentItemDto
   */
  name: string;
  /**
   * Config key of the document
   * @type {string}
   * @memberof DocumentItemDto
   */
  blockName: string;
  /**
   * Contents of the document
   * @type {object}
   * @memberof DocumentItemDto
   */
  content: object;
  /**
   * The json schema for form validation
   * @type {object}
   * @memberof DocumentItemDto
   */
  schema: object;
  /**
   * The zod validation error or null
   * @type {object}
   * @memberof DocumentItemDto
   */
  validationError: object;
  /**
   * The ui config for interface rendering
   * @type {object}
   * @memberof DocumentItemDto
   */
  ui: object;
  /**
   * Document metadata
   * @type {object}
   * @memberof DocumentItemDto
   */
  meta: object;
  /**
   * Indicates if the document is invalidated
   * @type {boolean}
   * @memberof DocumentItemDto
   */
  isInvalidated: boolean;
  /**
   * Indicates if the document is pending removal
   * @type {boolean}
   * @memberof DocumentItemDto
   */
  isPendingRemoval: boolean;
  /**
   * Version of the document
   * @type {number}
   * @memberof DocumentItemDto
   */
  version: number;
  /**
   * Index of the document
   * @type {number}
   * @memberof DocumentItemDto
   */
  index: number;
  /**
   * Transition when this document was created
   * @type {object}
   * @memberof DocumentItemDto
   */
  transition: object;
  /**
   * Place when this document was created
   * @type {string}
   * @memberof DocumentItemDto
   */
  place: string | null;
  /**
   * Labels associated with the document\'s namespace
   * @type {Array<string>}
   * @memberof DocumentItemDto
   */
  labels: Array<string>;
  /**
   * Tags associated with the document for categorization and filtering
   * @type {Array<string>}
   * @memberof DocumentItemDto
   */
  tags: Array<string>;
  /**
   * Date when the document was created
   * @type {string}
   * @memberof DocumentItemDto
   */
  createdAt: string;
  /**
   * Date when the document was last updated
   * @type {string}
   * @memberof DocumentItemDto
   */
  updatedAt: string;
  /**
   * ID of the workspace the document belongs to
   * @type {string}
   * @memberof DocumentItemDto
   */
  workspaceId: string;
  /**
   * ID of the pipeline the document belongs to
   * @type {string}
   * @memberof DocumentItemDto
   */
  pipelineId: string;
  /**
   * ID of the workflow the document belongs to
   * @type {string}
   * @memberof DocumentItemDto
   */
  workflowId: string;
}
/**
 *
 * @export
 * @interface DocumentSortByDto
 */
export interface DocumentSortByDto {
  /**
   *
   * @type {string}
   * @memberof DocumentSortByDto
   */
  field: DocumentSortByDtoFieldEnum;
  /**
   *
   * @type {string}
   * @memberof DocumentSortByDto
   */
  order: DocumentSortByDtoOrderEnum;
}

export const DocumentSortByDtoFieldEnum = {
  Id: 'id',
  MessageId: 'messageId',
  BlockName: 'blockName',
  WorkspaceId: 'workspaceId',
  PipelineId: 'pipelineId',
  Content: 'content',
  Schema: 'schema',
  Error: 'error',
  Ui: 'ui',
  Tags: 'tags',
  Meta: 'meta',
  IsInvalidated: 'isInvalidated',
  IsPendingRemoval: 'isPendingRemoval',
  WorkflowIndex: 'workflowIndex',
  Version: 'version',
  Index: 'index',
  Transition: 'transition',
  Place: 'place',
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  Labels: 'labels',
  WorkflowId: 'workflowId',
  CreatedBy: 'createdBy',
} as const;

export type DocumentSortByDtoFieldEnum = (typeof DocumentSortByDtoFieldEnum)[keyof typeof DocumentSortByDtoFieldEnum];
export const DocumentSortByDtoOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type DocumentSortByDtoOrderEnum = (typeof DocumentSortByDtoOrderEnum)[keyof typeof DocumentSortByDtoOrderEnum];

/**
 *
 * @export
 * @interface FeaturesDto
 */
export interface FeaturesDto {
  /**
   * Sidebar feature configuration
   * @type {SidebarFeatureDto}
   * @memberof FeaturesDto
   */
  sidebar?: SidebarFeatureDto;
  /**
   * Workflow history feature configuration
   * @type {SidebarFeatureDto}
   * @memberof FeaturesDto
   */
  workflowHistory?: SidebarFeatureDto;
  /**
   * Workflow navigation feature configuration
   * @type {SidebarFeatureDto}
   * @memberof FeaturesDto
   */
  workflowNavigation?: SidebarFeatureDto;
  /**
   * Debug workflow feature configuration
   * @type {SidebarFeatureDto}
   * @memberof FeaturesDto
   */
  debugWorkflow?: SidebarFeatureDto;
  /**
   * File explorer feature configuration
   * @type {FileExplorerFeatureDto}
   * @memberof FeaturesDto
   */
  fileExplorer?: FileExplorerFeatureDto;
}
/**
 *
 * @export
 * @interface FileContentDto
 */
export interface FileContentDto {
  /**
   * Path of the file relative to workspace root
   * @type {string}
   * @memberof FileContentDto
   */
  path: string;
  /**
   * Content of the file
   * @type {string}
   * @memberof FileContentDto
   */
  content: string;
  /**
   * Parsed workflow configuration if the file is a YAML workflow file
   * @type {PipelineConfigDto}
   * @memberof FileContentDto
   */
  workflowConfig?: PipelineConfigDto;
}
/**
 *
 * @export
 * @interface FileExplorerFeatureDto
 */
export interface FileExplorerFeatureDto {
  /**
   * Whether the file explorer feature is enabled
   * @type {boolean}
   * @memberof FileExplorerFeatureDto
   */
  enabled?: boolean;
  /**
   * Volume name to use for file explorer
   * @type {string}
   * @memberof FileExplorerFeatureDto
   */
  volume?: string;
  /**
   * Additional options for file explorer
   * @type {object}
   * @memberof FileExplorerFeatureDto
   */
  options?: object;
}
/**
 *
 * @export
 * @interface FileExplorerNodeDto
 */
export interface FileExplorerNodeDto {
  /**
   * Unique identifier for the file/folder node
   * @type {string}
   * @memberof FileExplorerNodeDto
   */
  id: string;
  /**
   * Name of the file or folder
   * @type {string}
   * @memberof FileExplorerNodeDto
   */
  name: string;
  /**
   * Full path of the file or folder relative to workspace root
   * @type {string}
   * @memberof FileExplorerNodeDto
   */
  path: string;
  /**
   * Type of the node
   * @type {string}
   * @memberof FileExplorerNodeDto
   */
  type: FileExplorerNodeDtoTypeEnum;
  /**
   * Child nodes (only present for folders)
   * @type {Array<FileExplorerNodeDto>}
   * @memberof FileExplorerNodeDto
   */
  children?: Array<FileExplorerNodeDto>;
}

export const FileExplorerNodeDtoTypeEnum = {
  File: 'file',
  Folder: 'folder',
} as const;

export type FileExplorerNodeDtoTypeEnum =
  (typeof FileExplorerNodeDtoTypeEnum)[keyof typeof FileExplorerNodeDtoTypeEnum];

/**
 *
 * @export
 * @interface HubLoginRequestDto
 */
export interface HubLoginRequestDto {
  /**
   * Hub-signed ID token
   * @type {string}
   * @memberof HubLoginRequestDto
   */
  idToken: string;
}
/**
 *
 * @export
 * @interface HubLoginResponseDto
 */
export interface HubLoginResponseDto {
  /**
   * The logged in user id
   * @type {string}
   * @memberof HubLoginResponseDto
   */
  id: string;
  /**
   * A message
   * @type {string}
   * @memberof HubLoginResponseDto
   */
  message: string;
}
/**
 *
 * @export
 * @interface NamespaceControllerGetWorkflows200Response
 */
export interface NamespaceControllerGetWorkflows200Response {
  /**
   *
   * @type {Array<NamespaceItemDto>}
   * @memberof NamespaceControllerGetWorkflows200Response
   */
  data: Array<NamespaceItemDto>;
  /**
   *
   * @type {number}
   * @memberof NamespaceControllerGetWorkflows200Response
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof NamespaceControllerGetWorkflows200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof NamespaceControllerGetWorkflows200Response
   */
  limit: number;
}
/**
 *
 * @export
 * @interface NamespaceDto
 */
export interface NamespaceDto {
  /**
   * Unique identifier of the namespace
   * @type {string}
   * @memberof NamespaceDto
   */
  id: string;
  /**
   * Name of the namespace
   * @type {string}
   * @memberof NamespaceDto
   */
  name: string;
  /**
   * Unique identifier of the workspace this namespace belongs to
   * @type {string}
   * @memberof NamespaceDto
   */
  workspaceId: string;
  /**
   * Unique identifier of the pipeline this namespace belongs to
   * @type {string}
   * @memberof NamespaceDto
   */
  pipelineId: string;
  /**
   * Metadata of this namespace
   * @type {{ [key: string]: any; }}
   * @memberof NamespaceDto
   */
  metadata: { [key: string]: any };
  /**
   * Parent namespace ID
   * @type {string}
   * @memberof NamespaceDto
   */
  parentId: string | null;
}
/**
 *
 * @export
 * @interface NamespaceFilterDto
 */
export interface NamespaceFilterDto {
  /**
   *
   * @type {string}
   * @memberof NamespaceFilterDto
   */
  workspaceId?: string;
  /**
   *
   * @type {string}
   * @memberof NamespaceFilterDto
   */
  pipelineId?: string;
}
/**
 *
 * @export
 * @interface NamespaceItemDto
 */
export interface NamespaceItemDto {
  /**
   * Unique identifier of the namespace
   * @type {string}
   * @memberof NamespaceItemDto
   */
  id: string;
  /**
   * Name of the namespace
   * @type {string}
   * @memberof NamespaceItemDto
   */
  name: string;
  /**
   * Metadata of this namespace
   * @type {{ [key: string]: any; }}
   * @memberof NamespaceItemDto
   */
  metadata: { [key: string]: any };
  /**
   * Parent namespace ID
   * @type {string}
   * @memberof NamespaceItemDto
   */
  parentId: string | null;
}
/**
 *
 * @export
 * @interface NamespaceSortByDto
 */
export interface NamespaceSortByDto {
  /**
   *
   * @type {string}
   * @memberof NamespaceSortByDto
   */
  field: NamespaceSortByDtoFieldEnum;
  /**
   *
   * @type {string}
   * @memberof NamespaceSortByDto
   */
  order: NamespaceSortByDtoOrderEnum;
}

export const NamespaceSortByDtoFieldEnum = {
  Id: 'id',
  Name: 'name',
  WorkspaceId: 'workspaceId',
  PipelineId: 'pipelineId',
  ParentId: 'parentId',
  Metadata: 'metadata',
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  CreatedBy: 'createdBy',
} as const;

export type NamespaceSortByDtoFieldEnum =
  (typeof NamespaceSortByDtoFieldEnum)[keyof typeof NamespaceSortByDtoFieldEnum];
export const NamespaceSortByDtoOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type NamespaceSortByDtoOrderEnum =
  (typeof NamespaceSortByDtoOrderEnum)[keyof typeof NamespaceSortByDtoOrderEnum];

/**
 *
 * @export
 * @interface PaginatedDto
 */
export interface PaginatedDto {
  /**
   *
   * @type {Array<object>}
   * @memberof PaginatedDto
   */
  data: Array<object>;
  /**
   *
   * @type {number}
   * @memberof PaginatedDto
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof PaginatedDto
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof PaginatedDto
   */
  limit: number;
}
/**
 *
 * @export
 * @interface PipelineConfigDto
 */
export interface PipelineConfigDto {
  /**
   * The config Key of the pipeline
   * @type {string}
   * @memberof PipelineConfigDto
   */
  blockName: string;
  /**
   * The title of the pipeline type
   * @type {string}
   * @memberof PipelineConfigDto
   */
  title?: string;
  /**
   * The description of the pipeline type
   * @type {string}
   * @memberof PipelineConfigDto
   */
  description?: string;
  /**
   * The json schema for form validation
   * @type {object}
   * @memberof PipelineConfigDto
   */
  schema?: object;
  /**
   * The ui config for interface rendering
   * @type {object}
   * @memberof PipelineConfigDto
   */
  ui?: object;
  /**
   * The state machine transitions
   * @type {Array<string>}
   * @memberof PipelineConfigDto
   */
  transitions?: Array<string>;
}
/**
 *
 * @export
 * @interface PipelineControllerBatchDeletePipelines200Response
 */
export interface PipelineControllerBatchDeletePipelines200Response {
  /**
   * Successfully deleted pipeline IDs
   * @type {Array<string>}
   * @memberof PipelineControllerBatchDeletePipelines200Response
   */
  deleted?: Array<string>;
  /**
   * Failed deletions with error details
   * @type {Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>}
   * @memberof PipelineControllerBatchDeletePipelines200Response
   */
  failed?: Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>;
}
/**
 *
 * @export
 * @interface PipelineControllerBatchDeletePipelines200ResponseFailedInner
 */
export interface PipelineControllerBatchDeletePipelines200ResponseFailedInner {
  /**
   *
   * @type {string}
   * @memberof PipelineControllerBatchDeletePipelines200ResponseFailedInner
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof PipelineControllerBatchDeletePipelines200ResponseFailedInner
   */
  error?: string;
}
/**
 *
 * @export
 * @interface PipelineControllerBatchDeletePipelinesRequest
 */
export interface PipelineControllerBatchDeletePipelinesRequest {
  /**
   * Array of pipeline IDs to delete
   * @type {Array<string>}
   * @memberof PipelineControllerBatchDeletePipelinesRequest
   */
  ids: Array<string>;
}
/**
 *
 * @export
 * @interface PipelineControllerGetPipelines200Response
 */
export interface PipelineControllerGetPipelines200Response {
  /**
   *
   * @type {Array<PipelineItemDto>}
   * @memberof PipelineControllerGetPipelines200Response
   */
  data: Array<PipelineItemDto>;
  /**
   *
   * @type {number}
   * @memberof PipelineControllerGetPipelines200Response
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof PipelineControllerGetPipelines200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof PipelineControllerGetPipelines200Response
   */
  limit: number;
}
/**
 *
 * @export
 * @interface PipelineCreateDto
 */
export interface PipelineCreateDto {
  /**
   * Process config key identifier for the pipeline
   * @type {string}
   * @memberof PipelineCreateDto
   */
  blockName: string;
  /**
   * Human-readable title for the pipeline
   * @type {string}
   * @memberof PipelineCreateDto
   */
  title?: string | null;
  /**
   * Array of labels/tags associated with the pipeline
   * @type {Array<string>}
   * @memberof PipelineCreateDto
   */
  labels?: Array<string>;
  /**
   * UUID of the workspace the pipeline belongs to
   * @type {string}
   * @memberof PipelineCreateDto
   */
  workspaceId: string;
  /**
   * Start transition for the run
   * @type {string}
   * @memberof PipelineCreateDto
   */
  transition?: string | null;
  /**
   * Arguments for the pipeline run
   * @type {{ [key: string]: any; }}
   * @memberof PipelineCreateDto
   */
  args?: { [key: string]: any } | null;
}
/**
 *
 * @export
 * @interface PipelineDto
 */
export interface PipelineDto {
  /**
   * Unique identifier of the pipeline
   * @type {string}
   * @memberof PipelineDto
   */
  id: string;
  /**
   * Config key of the pipeline
   * @type {string}
   * @memberof PipelineDto
   */
  blockName: string;
  /**
   * Display title of the pipeline
   * @type {string}
   * @memberof PipelineDto
   */
  title: string;
  /**
   * Run number for identification if no title is given.
   * @type {number}
   * @memberof PipelineDto
   */
  run: number;
  /**
   * Tags associated with the pipeline for categorization and filtering
   * @type {Array<string>}
   * @memberof PipelineDto
   */
  labels: Array<string>;
  /**
   * Order position of the pipeline in listings
   * @type {number}
   * @memberof PipelineDto
   */
  order: number;
  /**
   * Current status of the pipeline
   * @type {PipelineStatus}
   * @memberof PipelineDto
   */
  status: PipelineStatus;
  /**
   * Contextual information available to the pipeline
   * @type {object}
   * @memberof PipelineDto
   */
  context: object;
  /**
   * The json schema for form validation
   * @type {object}
   * @memberof PipelineDto
   */
  schema: object;
  /**
   * The ui config for interface rendering
   * @type {object}
   * @memberof PipelineDto
   */
  ui: object;
  /**
   * Timestamp when the pipeline was created
   * @type {string}
   * @memberof PipelineDto
   */
  createdAt: string;
  /**
   * Timestamp when the pipeline was last updated
   * @type {string}
   * @memberof PipelineDto
   */
  updatedAt: string;
  /**
   * Identifier of the workspace that contains this pipeline
   * @type {string}
   * @memberof PipelineDto
   */
  workspaceId: string;
  /**
   * ID of parent pipeline. Is Null for root pipelines
   * @type {object}
   * @memberof PipelineDto
   */
  parentId: object;
  /**
   * Number of child pipelines
   * @type {number}
   * @memberof PipelineDto
   */
  hasChildren: number;
}

/**
 *
 * @export
 * @interface PipelineFilterDto
 */
export interface PipelineFilterDto {
  /**
   *
   * @type {string}
   * @memberof PipelineFilterDto
   */
  workspaceId?: string;
  /**
   *
   * @type {object}
   * @memberof PipelineFilterDto
   */
  parentId?: object;
}
/**
 *
 * @export
 * @interface PipelineItemDto
 */
export interface PipelineItemDto {
  /**
   * Unique identifier of the pipeline
   * @type {string}
   * @memberof PipelineItemDto
   */
  id: string;
  /**
   * Config key of the pipeline
   * @type {string}
   * @memberof PipelineItemDto
   */
  blockName: string;
  /**
   * Display title of the pipeline
   * @type {string}
   * @memberof PipelineItemDto
   */
  title: string;
  /**
   * Run number for identification if no title is given.
   * @type {number}
   * @memberof PipelineItemDto
   */
  run: number;
  /**
   * Tags associated with the pipeline for categorization and filtering
   * @type {Array<string>}
   * @memberof PipelineItemDto
   */
  labels: Array<string>;
  /**
   * Order position of the pipeline in listings
   * @type {number}
   * @memberof PipelineItemDto
   */
  order: number;
  /**
   * Current status of the pipeline
   * @type {PipelineStatus}
   * @memberof PipelineItemDto
   */
  status: PipelineStatus;
  /**
   * Timestamp when the pipeline was created
   * @type {string}
   * @memberof PipelineItemDto
   */
  createdAt: string;
  /**
   * Timestamp when the pipeline was last updated
   * @type {string}
   * @memberof PipelineItemDto
   */
  updatedAt: string;
  /**
   * Identifier of the workspace that contains this pipeline
   * @type {string}
   * @memberof PipelineItemDto
   */
  workspaceId: string;
  /**
   * ID of parent pipeline. Is Null for root pipelines
   * @type {object}
   * @memberof PipelineItemDto
   */
  parentId: object;
  /**
   * Number of child pipelines
   * @type {number}
   * @memberof PipelineItemDto
   */
  hasChildren: number;
}

/**
 *
 * @export
 * @interface PipelineSortByDto
 */
export interface PipelineSortByDto {
  /**
   *
   * @type {string}
   * @memberof PipelineSortByDto
   */
  field: PipelineSortByDtoFieldEnum;
  /**
   *
   * @type {string}
   * @memberof PipelineSortByDto
   */
  order: PipelineSortByDtoOrderEnum;
}

export const PipelineSortByDtoFieldEnum = {
  Id: 'id',
  BlockName: 'blockName',
  Title: 'title',
  Run: 'run',
  Labels: 'labels',
  Index: 'index',
  Status: 'status',
  EventCorrelationId: 'eventCorrelationId',
  Args: 'args',
  Context: 'context',
  Schema: 'schema',
  Error: 'error',
  Ui: 'ui',
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  WorkspaceId: 'workspaceId',
  CreatedBy: 'createdBy',
  ParentId: 'parentId',
} as const;

export type PipelineSortByDtoFieldEnum = (typeof PipelineSortByDtoFieldEnum)[keyof typeof PipelineSortByDtoFieldEnum];
export const PipelineSortByDtoOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type PipelineSortByDtoOrderEnum = (typeof PipelineSortByDtoOrderEnum)[keyof typeof PipelineSortByDtoOrderEnum];

/**
 *
 * @export
 * @interface PipelineSourceDto
 */
export interface PipelineSourceDto {
  /**
   *
   * @type {string}
   * @memberof PipelineSourceDto
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PipelineSourceDto
   */
  filePath: string | null;
  /**
   *
   * @type {string}
   * @memberof PipelineSourceDto
   */
  raw: string | null;
}
/**
 * Current status of the pipeline
 * @export
 * @enum {string}
 */

export const PipelineStatus = {
  Pending: 'pending',
  Running: 'running',
  Paused: 'paused',
  Completed: 'completed',
  Failed: 'failed',
  Canceled: 'canceled',
} as const;

export type PipelineStatus = (typeof PipelineStatus)[keyof typeof PipelineStatus];

/**
 *
 * @export
 * @interface PipelineUpdateDto
 */
export interface PipelineUpdateDto {
  /**
   * Human-readable title for the pipeline
   * @type {string}
   * @memberof PipelineUpdateDto
   */
  title?: string;
  /**
   * Array of labels/tags associated with the pipeline
   * @type {Array<string>}
   * @memberof PipelineUpdateDto
   */
  labels?: Array<string>;
}
/**
 *
 * @export
 * @interface RunPipelinePayloadDto
 */
export interface RunPipelinePayloadDto {
  /**
   *
   * @type {object}
   * @memberof RunPipelinePayloadDto
   */
  transition?: object;
}
/**
 *
 * @export
 * @interface SidebarFeatureDto
 */
export interface SidebarFeatureDto {
  /**
   * Whether the sidebar feature is enabled
   * @type {boolean}
   * @memberof SidebarFeatureDto
   */
  enabled?: boolean;
}
/**
 *
 * @export
 * @interface VolumeDto
 */
export interface VolumeDto {
  /**
   * Path of the volume
   * @type {string}
   * @memberof VolumeDto
   */
  path: string;
  /**
   * Permissions for the volume
   * @type {Array<string>}
   * @memberof VolumeDto
   */
  permissions: Array<VolumeDtoPermissionsEnum>;
}

export const VolumeDtoPermissionsEnum = {
  Read: 'read',
  Write: 'write',
} as const;

export type VolumeDtoPermissionsEnum = (typeof VolumeDtoPermissionsEnum)[keyof typeof VolumeDtoPermissionsEnum];

/**
 *
 * @export
 * @interface WorkerInfoDto
 */
export interface WorkerInfoDto {
  /**
   * Worker Client ID
   * @type {string}
   * @memberof WorkerInfoDto
   */
  clientId?: string;
  /**
   * Is worker configured.
   * @type {boolean}
   * @memberof WorkerInfoDto
   */
  isConfigured: boolean;
  /**
   * Current Timestamp.
   * @type {string}
   * @memberof WorkerInfoDto
   */
  timestamp: string;
}
/**
 *
 * @export
 * @interface WorkflowControllerGetWorkflows200Response
 */
export interface WorkflowControllerGetWorkflows200Response {
  /**
   *
   * @type {Array<WorkflowItemDto>}
   * @memberof WorkflowControllerGetWorkflows200Response
   */
  data: Array<WorkflowItemDto>;
  /**
   *
   * @type {number}
   * @memberof WorkflowControllerGetWorkflows200Response
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof WorkflowControllerGetWorkflows200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof WorkflowControllerGetWorkflows200Response
   */
  limit: number;
}
/**
 *
 * @export
 * @interface WorkflowDto
 */
export interface WorkflowDto {
  /**
   * Unique identifier of the workflow
   * @type {string}
   * @memberof WorkflowDto
   */
  id: string;
  /**
   * Config key of the workflow
   * @type {string}
   * @memberof WorkflowDto
   */
  blockName: string;
  /**
   * Display title of the workflow
   * @type {string}
   * @memberof WorkflowDto
   */
  title: string;
  /**
   * Index position of the workflow in the pipeline sequence
   * @type {number}
   * @memberof WorkflowDto
   */
  index: number;
  /**
   * Tags associated with the workflow for categorization and filtering
   * @type {Array<string>}
   * @memberof WorkflowDto
   */
  labels: Array<string>;
  /**
   * Completion percentage of the workflow (0-100)
   * @type {number}
   * @memberof WorkflowDto
   */
  progress: number;
  /**
   * Current status of the workflow
   * @type {WorkflowState}
   * @memberof WorkflowDto
   */
  status: WorkflowState;
  /**
   *
   * @type {boolean}
   * @memberof WorkflowDto
   */
  hasError: boolean;
  /**
   * Error message if workflow execution failed
   * @type {string}
   * @memberof WorkflowDto
   */
  errorMessage?: string | null;
  /**
   * Current place in the workflow state machine
   * @type {string}
   * @memberof WorkflowDto
   */
  place: string;
  /**
   * Available transitions for the current place in the workflow
   * @type {Array<object>}
   * @memberof WorkflowDto
   */
  availableTransitions?: Array<object> | null;
  /**
   * History of state transitions within the workflow
   * @type {object}
   * @memberof WorkflowDto
   */
  history?: object | null;
  /**
   * The json schema for form validation
   * @type {object}
   * @memberof WorkflowDto
   */
  schema: object;
  /**
   * Ui schema config for the workflow
   * @type {{ [key: string]: any; }}
   * @memberof WorkflowDto
   */
  ui?: { [key: string]: any } | null;
  /**
   * Date and time when the workflow was created
   * @type {string}
   * @memberof WorkflowDto
   */
  createdAt: string;
  /**
   * Date and time when the workflow was last updated
   * @type {string}
   * @memberof WorkflowDto
   */
  updatedAt: string;
  /**
   * Unique identifier of the workspace this workflow belongs to
   * @type {string}
   * @memberof WorkflowDto
   */
  workspaceId: string;
  /**
   * Unique identifier of the pipeline this workflow belongs to
   * @type {string}
   * @memberof WorkflowDto
   */
  pipelineId: string;
  /**
   * Unique identifier of the namespace this workflow belongs to
   * @type {string}
   * @memberof WorkflowDto
   */
  namespaceId: string;
}

/**
 *
 * @export
 * @interface WorkflowFilterDto
 */
export interface WorkflowFilterDto {
  /**
   *
   * @type {string}
   * @memberof WorkflowFilterDto
   */
  namespaceId?: string;
  /**
   *
   * @type {string}
   * @memberof WorkflowFilterDto
   */
  pipelineId?: string;
}
/**
 *
 * @export
 * @interface WorkflowItemDto
 */
export interface WorkflowItemDto {
  /**
   * Unique identifier of the workflow item
   * @type {string}
   * @memberof WorkflowItemDto
   */
  id: string;
  /**
   * Config key of the workflow
   * @type {string}
   * @memberof WorkflowItemDto
   */
  blockName: string;
  /**
   * Display title of the workflow
   * @type {string}
   * @memberof WorkflowItemDto
   */
  title: string;
  /**
   * Index position of the workflow item in a sequence
   * @type {number}
   * @memberof WorkflowItemDto
   */
  index: number;
  /**
   * Tags associated with the workflow for categorization and filtering
   * @type {Array<string>}
   * @memberof WorkflowItemDto
   */
  labels: Array<string>;
  /**
   * Completion percentage of the workflow item (0-100)
   * @type {number}
   * @memberof WorkflowItemDto
   */
  progress: number;
  /**
   * Current status of the workflow
   * @type {WorkflowState}
   * @memberof WorkflowItemDto
   */
  status: WorkflowState;
  /**
   *
   * @type {boolean}
   * @memberof WorkflowItemDto
   */
  hasError: boolean;
  /**
   * Current place in the workflow state machine
   * @type {string}
   * @memberof WorkflowItemDto
   */
  place: string;
  /**
   * Date and time when the workflow item was created
   * @type {string}
   * @memberof WorkflowItemDto
   */
  createdAt: string;
  /**
   * Date and time when the workflow item was last updated
   * @type {string}
   * @memberof WorkflowItemDto
   */
  updatedAt: string;
  /**
   * Unique identifier of the workspace this workflow item belongs to
   * @type {string}
   * @memberof WorkflowItemDto
   */
  workspaceId: string;
  /**
   * Unique identifier of the pipeline this workflow belongs to
   * @type {string}
   * @memberof WorkflowItemDto
   */
  pipelineId: string;
  /**
   * Unique identifier of the namespace this workflow belongs to
   * @type {string}
   * @memberof WorkflowItemDto
   */
  namespaceId: string;
}

/**
 *
 * @export
 * @interface WorkflowSortByDto
 */
export interface WorkflowSortByDto {
  /**
   *
   * @type {string}
   * @memberof WorkflowSortByDto
   */
  field: WorkflowSortByDtoFieldEnum;
  /**
   *
   * @type {string}
   * @memberof WorkflowSortByDto
   */
  order: WorkflowSortByDtoOrderEnum;
}

export const WorkflowSortByDtoFieldEnum = {
  Id: 'id',
  BlockName: 'blockName',
  Title: 'title',
  Index: 'index',
  Progress: 'progress',
  Status: 'status',
  HasError: 'hasError',
  ErrorMessage: 'errorMessage',
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  Place: 'place',
  TransitionResults: 'transitionResults',
  InputData: 'inputData',
  Result: 'result',
  AvailableTransitions: 'availableTransitions',
  History: 'history',
  Schema: 'schema',
  Error: 'error',
  Ui: 'ui',
  NamespaceId: 'namespaceId',
  PipelineId: 'pipelineId',
  Labels: 'labels',
  HashRecord: 'hashRecord',
  CreatedBy: 'createdBy',
} as const;

export type WorkflowSortByDtoFieldEnum = (typeof WorkflowSortByDtoFieldEnum)[keyof typeof WorkflowSortByDtoFieldEnum];
export const WorkflowSortByDtoOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type WorkflowSortByDtoOrderEnum = (typeof WorkflowSortByDtoOrderEnum)[keyof typeof WorkflowSortByDtoOrderEnum];

/**
 * Current status of the workflow
 * @export
 * @enum {string}
 */

export const WorkflowState = {
  Pending: 'pending',
  Running: 'running',
  Waiting: 'waiting',
  Completed: 'completed',
  Failed: 'failed',
  Canceled: 'canceled',
} as const;

export type WorkflowState = (typeof WorkflowState)[keyof typeof WorkflowState];

/**
 *
 * @export
 * @interface WorkspaceConfigDto
 */
export interface WorkspaceConfigDto {
  /**
   * Config key of the workspace
   * @type {string}
   * @memberof WorkspaceConfigDto
   */
  blockName: string;
  /**
   * The title of the workspace type
   * @type {string}
   * @memberof WorkspaceConfigDto
   */
  title?: string;
  /**
   * Volumes configuration
   * @type {{ [key: string]: any; }}
   * @memberof WorkspaceConfigDto
   */
  volumes?: { [key: string]: any };
  /**
   * Features configuration
   * @type {FeaturesDto}
   * @memberof WorkspaceConfigDto
   */
  features?: FeaturesDto;
}
/**
 *
 * @export
 * @interface WorkspaceControllerBatchDeleteWorkspaces200Response
 */
export interface WorkspaceControllerBatchDeleteWorkspaces200Response {
  /**
   * Successfully deleted workspace IDs
   * @type {Array<string>}
   * @memberof WorkspaceControllerBatchDeleteWorkspaces200Response
   */
  deleted?: Array<string>;
  /**
   * Failed deletions with error details
   * @type {Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>}
   * @memberof WorkspaceControllerBatchDeleteWorkspaces200Response
   */
  failed?: Array<PipelineControllerBatchDeletePipelines200ResponseFailedInner>;
}
/**
 *
 * @export
 * @interface WorkspaceControllerBatchDeleteWorkspacesRequest
 */
export interface WorkspaceControllerBatchDeleteWorkspacesRequest {
  /**
   * Array of workspace IDs to delete
   * @type {Array<string>}
   * @memberof WorkspaceControllerBatchDeleteWorkspacesRequest
   */
  ids: Array<string>;
}
/**
 *
 * @export
 * @interface WorkspaceControllerGetWorkspaces200Response
 */
export interface WorkspaceControllerGetWorkspaces200Response {
  /**
   *
   * @type {Array<WorkspaceItemDto>}
   * @memberof WorkspaceControllerGetWorkspaces200Response
   */
  data: Array<WorkspaceItemDto>;
  /**
   *
   * @type {number}
   * @memberof WorkspaceControllerGetWorkspaces200Response
   */
  total: number;
  /**
   *
   * @type {number}
   * @memberof WorkspaceControllerGetWorkspaces200Response
   */
  page: number;
  /**
   *
   * @type {number}
   * @memberof WorkspaceControllerGetWorkspaces200Response
   */
  limit: number;
}
/**
 *
 * @export
 * @interface WorkspaceCreateDto
 */
export interface WorkspaceCreateDto {
  /**
   * Human-readable title for the workspace. If not provided, a default name will be generated
   * @type {string}
   * @memberof WorkspaceCreateDto
   */
  title?: string;
  /**
   * The config key of the workspace
   * @type {string}
   * @memberof WorkspaceCreateDto
   */
  blockName: string;
}
/**
 *
 * @export
 * @interface WorkspaceDto
 */
export interface WorkspaceDto {
  /**
   * Unique identifier of the workspace
   * @type {string}
   * @memberof WorkspaceDto
   */
  id: string;
  /**
   * Config key of the workspace
   * @type {string}
   * @memberof WorkspaceDto
   */
  blockName: string;
  /**
   * Display title of the workspace
   * @type {string}
   * @memberof WorkspaceDto
   */
  title: string;
  /**
   * Indicates whether the workspace is locked for editing
   * @type {boolean}
   * @memberof WorkspaceDto
   */
  isLocked: boolean;
  /**
   * Timestamp when the workspace was created
   * @type {string}
   * @memberof WorkspaceDto
   */
  createdAt: string;
  /**
   * Timestamp when the workspace was last updated
   * @type {string}
   * @memberof WorkspaceDto
   */
  updatedAt: string;
  /**
   * Volumes configuration
   * @type {{ [key: string]: any; }}
   * @memberof WorkspaceDto
   */
  volumes?: { [key: string]: any };
  /**
   * Features configuration
   * @type {FeaturesDto}
   * @memberof WorkspaceDto
   */
  features?: FeaturesDto;
}
/**
 *
 * @export
 * @interface WorkspaceItemDto
 */
export interface WorkspaceItemDto {
  /**
   * Unique identifier of the workspace item
   * @type {string}
   * @memberof WorkspaceItemDto
   */
  id: string;
  /**
   * Config key of the workspace
   * @type {string}
   * @memberof WorkspaceItemDto
   */
  blockName: string;
  /**
   * Display title of the workspace
   * @type {string}
   * @memberof WorkspaceItemDto
   */
  title: string;
  /**
   * Timestamp when the workspace item was created
   * @type {string}
   * @memberof WorkspaceItemDto
   */
  createdAt: string;
  /**
   * Timestamp when the workspace item was last updated
   * @type {string}
   * @memberof WorkspaceItemDto
   */
  updatedAt: string;
}
/**
 *
 * @export
 * @interface WorkspaceSortByDto
 */
export interface WorkspaceSortByDto {
  /**
   *
   * @type {string}
   * @memberof WorkspaceSortByDto
   */
  field: WorkspaceSortByDtoFieldEnum;
  /**
   *
   * @type {string}
   * @memberof WorkspaceSortByDto
   */
  order: WorkspaceSortByDtoOrderEnum;
}

export const WorkspaceSortByDtoFieldEnum = {
  Id: 'id',
  Title: 'title',
  BlockName: 'blockName',
  CreatedAt: 'createdAt',
  UpdatedAt: 'updatedAt',
  CreatedBy: 'createdBy',
} as const;

export type WorkspaceSortByDtoFieldEnum =
  (typeof WorkspaceSortByDtoFieldEnum)[keyof typeof WorkspaceSortByDtoFieldEnum];
export const WorkspaceSortByDtoOrderEnum = {
  Asc: 'ASC',
  Desc: 'DESC',
} as const;

export type WorkspaceSortByDtoOrderEnum =
  (typeof WorkspaceSortByDtoOrderEnum)[keyof typeof WorkspaceSortByDtoOrderEnum];

/**
 *
 * @export
 * @interface WorkspaceUpdateDto
 */
export interface WorkspaceUpdateDto {
  /**
   * Human-readable title for the workspace
   * @type {string}
   * @memberof WorkspaceUpdateDto
   */
  title?: string;
}

/**
 * ApiV1AdminRolesApi - axios parameter creator
 * @export
 */
export const ApiV1AdminRolesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Requires ADMIN role.
     * @summary Create a new role
     * @param {AdminRoleCreateDto} adminRoleCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerCreateRole: async (
      adminRoleCreateDto: AdminRoleCreateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'adminRoleCreateDto' is not null or undefined
      assertParamExists('adminRoleControllerCreateRole', 'adminRoleCreateDto', adminRoleCreateDto);
      const localVarPath = `/api/v1/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(adminRoleCreateDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Cannot delete the ADMIN role or roles assigned to users.
     * @summary Delete a role
     * @param {string} id The UUID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerDeleteRole: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminRoleControllerDeleteRole', 'id', id);
      const localVarPath = `/api/v1/admin/roles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Returns role details including user count.
     * @summary Get a role by ID
     * @param {string} id The UUID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerGetRoleById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminRoleControllerGetRoleById', 'id', id);
      const localVarPath = `/api/v1/admin/roles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Returns all roles with user counts.
     * @summary List all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerGetRoles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/admin/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role.
     * @summary Update a role
     * @param {string} id The UUID of the role
     * @param {AdminRoleUpdateDto} adminRoleUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerUpdateRole: async (
      id: string,
      adminRoleUpdateDto: AdminRoleUpdateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminRoleControllerUpdateRole', 'id', id);
      // verify required parameter 'adminRoleUpdateDto' is not null or undefined
      assertParamExists('adminRoleControllerUpdateRole', 'adminRoleUpdateDto', adminRoleUpdateDto);
      const localVarPath = `/api/v1/admin/roles/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(adminRoleUpdateDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1AdminRolesApi - functional programming interface
 * @export
 */
export const ApiV1AdminRolesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1AdminRolesApiAxiosParamCreator(configuration);
  return {
    /**
     * Requires ADMIN role.
     * @summary Create a new role
     * @param {AdminRoleCreateDto} adminRoleCreateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminRoleControllerCreateRole(
      adminRoleCreateDto: AdminRoleCreateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminRoleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminRoleControllerCreateRole(
        adminRoleCreateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminRolesApi.adminRoleControllerCreateRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Cannot delete the ADMIN role or roles assigned to users.
     * @summary Delete a role
     * @param {string} id The UUID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminRoleControllerDeleteRole(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminRoleControllerDeleteRole(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminRolesApi.adminRoleControllerDeleteRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Returns role details including user count.
     * @summary Get a role by ID
     * @param {string} id The UUID of the role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminRoleControllerGetRoleById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminRoleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminRoleControllerGetRoleById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminRolesApi.adminRoleControllerGetRoleById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Returns all roles with user counts.
     * @summary List all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminRoleControllerGetRoles(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdminRoleItemDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminRoleControllerGetRoles(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminRolesApi.adminRoleControllerGetRoles']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role.
     * @summary Update a role
     * @param {string} id The UUID of the role
     * @param {AdminRoleUpdateDto} adminRoleUpdateDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminRoleControllerUpdateRole(
      id: string,
      adminRoleUpdateDto: AdminRoleUpdateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminRoleDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminRoleControllerUpdateRole(
        id,
        adminRoleUpdateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminRolesApi.adminRoleControllerUpdateRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1AdminRolesApi - factory interface
 * @export
 */
export const ApiV1AdminRolesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1AdminRolesApiFp(configuration);
  return {
    /**
     * Requires ADMIN role.
     * @summary Create a new role
     * @param {ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerCreateRole(
      requestParameters: ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminRoleDto> {
      return localVarFp
        .adminRoleControllerCreateRole(requestParameters.adminRoleCreateDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Cannot delete the ADMIN role or roles assigned to users.
     * @summary Delete a role
     * @param {ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerDeleteRole(
      requestParameters: ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .adminRoleControllerDeleteRole(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Returns role details including user count.
     * @summary Get a role by ID
     * @param {ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerGetRoleById(
      requestParameters: ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminRoleDto> {
      return localVarFp
        .adminRoleControllerGetRoleById(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Returns all roles with user counts.
     * @summary List all roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerGetRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<AdminRoleItemDto>> {
      return localVarFp.adminRoleControllerGetRoles(options).then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role.
     * @summary Update a role
     * @param {ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminRoleControllerUpdateRole(
      requestParameters: ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminRoleDto> {
      return localVarFp
        .adminRoleControllerUpdateRole(requestParameters.id, requestParameters.adminRoleUpdateDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1AdminRolesApi - interface
 * @export
 * @interface ApiV1AdminRolesApi
 */
export interface ApiV1AdminRolesApiInterface {
  /**
   * Requires ADMIN role.
   * @summary Create a new role
   * @param {ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApiInterface
   */
  adminRoleControllerCreateRole(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminRoleDto>;

  /**
   * Requires ADMIN role. Cannot delete the ADMIN role or roles assigned to users.
   * @summary Delete a role
   * @param {ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApiInterface
   */
  adminRoleControllerDeleteRole(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   * Requires ADMIN role. Returns role details including user count.
   * @summary Get a role by ID
   * @param {ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApiInterface
   */
  adminRoleControllerGetRoleById(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminRoleDto>;

  /**
   * Requires ADMIN role. Returns all roles with user counts.
   * @summary List all roles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApiInterface
   */
  adminRoleControllerGetRoles(options?: RawAxiosRequestConfig): AxiosPromise<Array<AdminRoleItemDto>>;

  /**
   * Requires ADMIN role.
   * @summary Update a role
   * @param {ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApiInterface
   */
  adminRoleControllerUpdateRole(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminRoleDto>;
}

/**
 * Request parameters for adminRoleControllerCreateRole operation in ApiV1AdminRolesApi.
 * @export
 * @interface ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest
 */
export interface ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest {
  /**
   *
   * @type {AdminRoleCreateDto}
   * @memberof ApiV1AdminRolesApiAdminRoleControllerCreateRole
   */
  readonly adminRoleCreateDto: AdminRoleCreateDto;
}

/**
 * Request parameters for adminRoleControllerDeleteRole operation in ApiV1AdminRolesApi.
 * @export
 * @interface ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest
 */
export interface ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest {
  /**
   * The UUID of the role
   * @type {string}
   * @memberof ApiV1AdminRolesApiAdminRoleControllerDeleteRole
   */
  readonly id: string;
}

/**
 * Request parameters for adminRoleControllerGetRoleById operation in ApiV1AdminRolesApi.
 * @export
 * @interface ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest
 */
export interface ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest {
  /**
   * The UUID of the role
   * @type {string}
   * @memberof ApiV1AdminRolesApiAdminRoleControllerGetRoleById
   */
  readonly id: string;
}

/**
 * Request parameters for adminRoleControllerUpdateRole operation in ApiV1AdminRolesApi.
 * @export
 * @interface ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest
 */
export interface ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest {
  /**
   * The UUID of the role
   * @type {string}
   * @memberof ApiV1AdminRolesApiAdminRoleControllerUpdateRole
   */
  readonly id: string;

  /**
   *
   * @type {AdminRoleUpdateDto}
   * @memberof ApiV1AdminRolesApiAdminRoleControllerUpdateRole
   */
  readonly adminRoleUpdateDto: AdminRoleUpdateDto;
}

/**
 * ApiV1AdminRolesApi - object-oriented interface
 * @export
 * @class ApiV1AdminRolesApi
 * @extends {BaseAPI}
 */
export class ApiV1AdminRolesApi extends BaseAPI implements ApiV1AdminRolesApiInterface {
  /**
   * Requires ADMIN role.
   * @summary Create a new role
   * @param {ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApi
   */
  public adminRoleControllerCreateRole(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerCreateRoleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminRolesApiFp(this.configuration)
      .adminRoleControllerCreateRole(requestParameters.adminRoleCreateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Cannot delete the ADMIN role or roles assigned to users.
   * @summary Delete a role
   * @param {ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApi
   */
  public adminRoleControllerDeleteRole(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerDeleteRoleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminRolesApiFp(this.configuration)
      .adminRoleControllerDeleteRole(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Returns role details including user count.
   * @summary Get a role by ID
   * @param {ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApi
   */
  public adminRoleControllerGetRoleById(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerGetRoleByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminRolesApiFp(this.configuration)
      .adminRoleControllerGetRoleById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Returns all roles with user counts.
   * @summary List all roles
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApi
   */
  public adminRoleControllerGetRoles(options?: RawAxiosRequestConfig) {
    return ApiV1AdminRolesApiFp(this.configuration)
      .adminRoleControllerGetRoles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role.
   * @summary Update a role
   * @param {ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminRolesApi
   */
  public adminRoleControllerUpdateRole(
    requestParameters: ApiV1AdminRolesApiAdminRoleControllerUpdateRoleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminRolesApiFp(this.configuration)
      .adminRoleControllerUpdateRole(requestParameters.id, requestParameters.adminRoleUpdateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1AdminSystemApi - axios parameter creator
 * @export
 */
export const ApiV1AdminSystemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Requires ADMIN role. Returns the list of active SSE connections.
     * @summary Active SSE connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSystemControllerGetConnections: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/admin/system/connections`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Returns system health including DB connectivity, memory usage, and uptime.
     * @summary System health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSystemControllerGetHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/admin/system/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Returns aggregate counts for users, workspaces, pipelines, and workflows.
     * @summary System-wide statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSystemControllerGetStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/admin/system/stats`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1AdminSystemApi - functional programming interface
 * @export
 */
export const ApiV1AdminSystemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1AdminSystemApiAxiosParamCreator(configuration);
  return {
    /**
     * Requires ADMIN role. Returns the list of active SSE connections.
     * @summary Active SSE connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminSystemControllerGetConnections(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminSystemControllerGetConnections(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminSystemApi.adminSystemControllerGetConnections']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Returns system health including DB connectivity, memory usage, and uptime.
     * @summary System health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminSystemControllerGetHealth(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminSystemControllerGetHealth(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminSystemApi.adminSystemControllerGetHealth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Returns aggregate counts for users, workspaces, pipelines, and workflows.
     * @summary System-wide statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminSystemControllerGetStats(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminSystemControllerGetStats(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminSystemApi.adminSystemControllerGetStats']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1AdminSystemApi - factory interface
 * @export
 */
export const ApiV1AdminSystemApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1AdminSystemApiFp(configuration);
  return {
    /**
     * Requires ADMIN role. Returns the list of active SSE connections.
     * @summary Active SSE connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSystemControllerGetConnections(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.adminSystemControllerGetConnections(options).then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Returns system health including DB connectivity, memory usage, and uptime.
     * @summary System health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSystemControllerGetHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.adminSystemControllerGetHealth(options).then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Returns aggregate counts for users, workspaces, pipelines, and workflows.
     * @summary System-wide statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminSystemControllerGetStats(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.adminSystemControllerGetStats(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1AdminSystemApi - interface
 * @export
 * @interface ApiV1AdminSystemApi
 */
export interface ApiV1AdminSystemApiInterface {
  /**
   * Requires ADMIN role. Returns the list of active SSE connections.
   * @summary Active SSE connections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminSystemApiInterface
   */
  adminSystemControllerGetConnections(options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * Requires ADMIN role. Returns system health including DB connectivity, memory usage, and uptime.
   * @summary System health check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminSystemApiInterface
   */
  adminSystemControllerGetHealth(options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * Requires ADMIN role. Returns aggregate counts for users, workspaces, pipelines, and workflows.
   * @summary System-wide statistics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminSystemApiInterface
   */
  adminSystemControllerGetStats(options?: RawAxiosRequestConfig): AxiosPromise<void>;
}

/**
 * ApiV1AdminSystemApi - object-oriented interface
 * @export
 * @class ApiV1AdminSystemApi
 * @extends {BaseAPI}
 */
export class ApiV1AdminSystemApi extends BaseAPI implements ApiV1AdminSystemApiInterface {
  /**
   * Requires ADMIN role. Returns the list of active SSE connections.
   * @summary Active SSE connections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminSystemApi
   */
  public adminSystemControllerGetConnections(options?: RawAxiosRequestConfig) {
    return ApiV1AdminSystemApiFp(this.configuration)
      .adminSystemControllerGetConnections(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Returns system health including DB connectivity, memory usage, and uptime.
   * @summary System health check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminSystemApi
   */
  public adminSystemControllerGetHealth(options?: RawAxiosRequestConfig) {
    return ApiV1AdminSystemApiFp(this.configuration)
      .adminSystemControllerGetHealth(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Returns aggregate counts for users, workspaces, pipelines, and workflows.
   * @summary System-wide statistics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminSystemApi
   */
  public adminSystemControllerGetStats(options?: RawAxiosRequestConfig) {
    return ApiV1AdminSystemApiFp(this.configuration)
      .adminSystemControllerGetStats(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1AdminUsersApi - axios parameter creator
 * @export
 */
export const ApiV1AdminUsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Requires ADMIN role. Replaces all existing role assignments.
     * @summary Assign roles to a user
     * @param {string} id The UUID of the user
     * @param {AdminUserAssignRolesDto} adminUserAssignRolesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerAssignRoles: async (
      id: string,
      adminUserAssignRolesDto: AdminUserAssignRolesDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminUserControllerAssignRoles', 'id', id);
      // verify required parameter 'adminUserAssignRolesDto' is not null or undefined
      assertParamExists('adminUserControllerAssignRoles', 'adminUserAssignRolesDto', adminUserAssignRolesDto);
      const localVarPath = `/api/v1/admin/users/{id}/roles`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminUserAssignRolesDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Returns user details including roles and permissions.
     * @summary Get a user by ID
     * @param {string} id The UUID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerGetUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminUserControllerGetUserById', 'id', id);
      const localVarPath = `/api/v1/admin/users/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Returns all users across the system.
     * @summary List all users with filters, sorting, and pagination
     * @param {string} [filter] JSON string of AdminUserFilterDto object
     * @param {string} [sortBy] JSON string array of AdminUserSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerGetUsers: async (
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/admin/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role.
     * @summary Remove a role from a user
     * @param {string} id The UUID of the user
     * @param {string} roleId The UUID of the role to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerRemoveRole: async (
      id: string,
      roleId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminUserControllerRemoveRole', 'id', id);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('adminUserControllerRemoveRole', 'roleId', roleId);
      const localVarPath = `/api/v1/admin/users/{id}/roles/{roleId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Requires ADMIN role. Cannot deactivate yourself.
     * @summary Activate or deactivate a user
     * @param {string} id The UUID of the user
     * @param {AdminUserUpdateStatusDto} adminUserUpdateStatusDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerUpdateUserStatus: async (
      id: string,
      adminUserUpdateStatusDto: AdminUserUpdateStatusDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('adminUserControllerUpdateUserStatus', 'id', id);
      // verify required parameter 'adminUserUpdateStatusDto' is not null or undefined
      assertParamExists('adminUserControllerUpdateUserStatus', 'adminUserUpdateStatusDto', adminUserUpdateStatusDto);
      const localVarPath = `/api/v1/admin/users/{id}/status`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        adminUserUpdateStatusDto,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1AdminUsersApi - functional programming interface
 * @export
 */
export const ApiV1AdminUsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1AdminUsersApiAxiosParamCreator(configuration);
  return {
    /**
     * Requires ADMIN role. Replaces all existing role assignments.
     * @summary Assign roles to a user
     * @param {string} id The UUID of the user
     * @param {AdminUserAssignRolesDto} adminUserAssignRolesDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUserControllerAssignRoles(
      id: string,
      adminUserAssignRolesDto: AdminUserAssignRolesDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerAssignRoles(
        id,
        adminUserAssignRolesDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminUsersApi.adminUserControllerAssignRoles']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Returns user details including roles and permissions.
     * @summary Get a user by ID
     * @param {string} id The UUID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUserControllerGetUserById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerGetUserById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminUsersApi.adminUserControllerGetUserById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Returns all users across the system.
     * @summary List all users with filters, sorting, and pagination
     * @param {string} [filter] JSON string of AdminUserFilterDto object
     * @param {string} [sortBy] JSON string array of AdminUserSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUserControllerGetUsers(
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserControllerGetUsers200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerGetUsers(
        filter,
        sortBy,
        page,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminUsersApi.adminUserControllerGetUsers']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role.
     * @summary Remove a role from a user
     * @param {string} id The UUID of the user
     * @param {string} roleId The UUID of the role to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUserControllerRemoveRole(
      id: string,
      roleId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerRemoveRole(id, roleId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminUsersApi.adminUserControllerRemoveRole']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Requires ADMIN role. Cannot deactivate yourself.
     * @summary Activate or deactivate a user
     * @param {string} id The UUID of the user
     * @param {AdminUserUpdateStatusDto} adminUserUpdateStatusDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async adminUserControllerUpdateUserStatus(
      id: string,
      adminUserUpdateStatusDto: AdminUserUpdateStatusDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdminUserDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserControllerUpdateUserStatus(
        id,
        adminUserUpdateStatusDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AdminUsersApi.adminUserControllerUpdateUserStatus']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1AdminUsersApi - factory interface
 * @export
 */
export const ApiV1AdminUsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1AdminUsersApiFp(configuration);
  return {
    /**
     * Requires ADMIN role. Replaces all existing role assignments.
     * @summary Assign roles to a user
     * @param {ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerAssignRoles(
      requestParameters: ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminUserDto> {
      return localVarFp
        .adminUserControllerAssignRoles(requestParameters.id, requestParameters.adminUserAssignRolesDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Returns user details including roles and permissions.
     * @summary Get a user by ID
     * @param {ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerGetUserById(
      requestParameters: ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminUserDto> {
      return localVarFp
        .adminUserControllerGetUserById(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Returns all users across the system.
     * @summary List all users with filters, sorting, and pagination
     * @param {ApiV1AdminUsersApiAdminUserControllerGetUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerGetUsers(
      requestParameters: ApiV1AdminUsersApiAdminUserControllerGetUsersRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminUserControllerGetUsers200Response> {
      return localVarFp
        .adminUserControllerGetUsers(
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.page,
          requestParameters.limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role.
     * @summary Remove a role from a user
     * @param {ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerRemoveRole(
      requestParameters: ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminUserDto> {
      return localVarFp
        .adminUserControllerRemoveRole(requestParameters.id, requestParameters.roleId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Requires ADMIN role. Cannot deactivate yourself.
     * @summary Activate or deactivate a user
     * @param {ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    adminUserControllerUpdateUserStatus(
      requestParameters: ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<AdminUserDto> {
      return localVarFp
        .adminUserControllerUpdateUserStatus(requestParameters.id, requestParameters.adminUserUpdateStatusDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1AdminUsersApi - interface
 * @export
 * @interface ApiV1AdminUsersApi
 */
export interface ApiV1AdminUsersApiInterface {
  /**
   * Requires ADMIN role. Replaces all existing role assignments.
   * @summary Assign roles to a user
   * @param {ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApiInterface
   */
  adminUserControllerAssignRoles(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminUserDto>;

  /**
   * Requires ADMIN role. Returns user details including roles and permissions.
   * @summary Get a user by ID
   * @param {ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApiInterface
   */
  adminUserControllerGetUserById(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminUserDto>;

  /**
   * Requires ADMIN role. Returns all users across the system.
   * @summary List all users with filters, sorting, and pagination
   * @param {ApiV1AdminUsersApiAdminUserControllerGetUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApiInterface
   */
  adminUserControllerGetUsers(
    requestParameters?: ApiV1AdminUsersApiAdminUserControllerGetUsersRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminUserControllerGetUsers200Response>;

  /**
   * Requires ADMIN role.
   * @summary Remove a role from a user
   * @param {ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApiInterface
   */
  adminUserControllerRemoveRole(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminUserDto>;

  /**
   * Requires ADMIN role. Cannot deactivate yourself.
   * @summary Activate or deactivate a user
   * @param {ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApiInterface
   */
  adminUserControllerUpdateUserStatus(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<AdminUserDto>;
}

/**
 * Request parameters for adminUserControllerAssignRoles operation in ApiV1AdminUsersApi.
 * @export
 * @interface ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest
 */
export interface ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest {
  /**
   * The UUID of the user
   * @type {string}
   * @memberof ApiV1AdminUsersApiAdminUserControllerAssignRoles
   */
  readonly id: string;

  /**
   *
   * @type {AdminUserAssignRolesDto}
   * @memberof ApiV1AdminUsersApiAdminUserControllerAssignRoles
   */
  readonly adminUserAssignRolesDto: AdminUserAssignRolesDto;
}

/**
 * Request parameters for adminUserControllerGetUserById operation in ApiV1AdminUsersApi.
 * @export
 * @interface ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest
 */
export interface ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest {
  /**
   * The UUID of the user
   * @type {string}
   * @memberof ApiV1AdminUsersApiAdminUserControllerGetUserById
   */
  readonly id: string;
}

/**
 * Request parameters for adminUserControllerGetUsers operation in ApiV1AdminUsersApi.
 * @export
 * @interface ApiV1AdminUsersApiAdminUserControllerGetUsersRequest
 */
export interface ApiV1AdminUsersApiAdminUserControllerGetUsersRequest {
  /**
   * JSON string of AdminUserFilterDto object
   * @type {string}
   * @memberof ApiV1AdminUsersApiAdminUserControllerGetUsers
   */
  readonly filter?: string;

  /**
   * JSON string array of AdminUserSortByDto objects
   * @type {string}
   * @memberof ApiV1AdminUsersApiAdminUserControllerGetUsers
   */
  readonly sortBy?: string;

  /**
   * Page number for pagination (starts at 1)
   * @type {number}
   * @memberof ApiV1AdminUsersApiAdminUserControllerGetUsers
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ApiV1AdminUsersApiAdminUserControllerGetUsers
   */
  readonly limit?: number;
}

/**
 * Request parameters for adminUserControllerRemoveRole operation in ApiV1AdminUsersApi.
 * @export
 * @interface ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest
 */
export interface ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest {
  /**
   * The UUID of the user
   * @type {string}
   * @memberof ApiV1AdminUsersApiAdminUserControllerRemoveRole
   */
  readonly id: string;

  /**
   * The UUID of the role to remove
   * @type {string}
   * @memberof ApiV1AdminUsersApiAdminUserControllerRemoveRole
   */
  readonly roleId: string;
}

/**
 * Request parameters for adminUserControllerUpdateUserStatus operation in ApiV1AdminUsersApi.
 * @export
 * @interface ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest
 */
export interface ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest {
  /**
   * The UUID of the user
   * @type {string}
   * @memberof ApiV1AdminUsersApiAdminUserControllerUpdateUserStatus
   */
  readonly id: string;

  /**
   *
   * @type {AdminUserUpdateStatusDto}
   * @memberof ApiV1AdminUsersApiAdminUserControllerUpdateUserStatus
   */
  readonly adminUserUpdateStatusDto: AdminUserUpdateStatusDto;
}

/**
 * ApiV1AdminUsersApi - object-oriented interface
 * @export
 * @class ApiV1AdminUsersApi
 * @extends {BaseAPI}
 */
export class ApiV1AdminUsersApi extends BaseAPI implements ApiV1AdminUsersApiInterface {
  /**
   * Requires ADMIN role. Replaces all existing role assignments.
   * @summary Assign roles to a user
   * @param {ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApi
   */
  public adminUserControllerAssignRoles(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerAssignRolesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminUsersApiFp(this.configuration)
      .adminUserControllerAssignRoles(requestParameters.id, requestParameters.adminUserAssignRolesDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Returns user details including roles and permissions.
   * @summary Get a user by ID
   * @param {ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApi
   */
  public adminUserControllerGetUserById(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerGetUserByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminUsersApiFp(this.configuration)
      .adminUserControllerGetUserById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Returns all users across the system.
   * @summary List all users with filters, sorting, and pagination
   * @param {ApiV1AdminUsersApiAdminUserControllerGetUsersRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApi
   */
  public adminUserControllerGetUsers(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerGetUsersRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminUsersApiFp(this.configuration)
      .adminUserControllerGetUsers(
        requestParameters.filter,
        requestParameters.sortBy,
        requestParameters.page,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role.
   * @summary Remove a role from a user
   * @param {ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApi
   */
  public adminUserControllerRemoveRole(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerRemoveRoleRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminUsersApiFp(this.configuration)
      .adminUserControllerRemoveRole(requestParameters.id, requestParameters.roleId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Requires ADMIN role. Cannot deactivate yourself.
   * @summary Activate or deactivate a user
   * @param {ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AdminUsersApi
   */
  public adminUserControllerUpdateUserStatus(
    requestParameters: ApiV1AdminUsersApiAdminUserControllerUpdateUserStatusRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AdminUsersApiFp(this.configuration)
      .adminUserControllerUpdateUserStatus(requestParameters.id, requestParameters.adminUserUpdateStatusDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1AuthApi - axios parameter creator
 * @export
 */
export const ApiV1AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/auth/worker/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Login via Hub
     * @param {HubLoginRequestDto} hubLoginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerHubLogin: async (
      hubLoginRequestDto: HubLoginRequestDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'hubLoginRequestDto' is not null or undefined
      assertParamExists('authControllerHubLogin', 'hubLoginRequestDto', hubLoginRequestDto);
      const localVarPath = `/api/v1/auth/oauth/hub`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hubLoginRequestDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/auth/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerRefresh: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/auth/refresh`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1AuthApi - functional programming interface
 * @export
 */
export const ApiV1AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1AuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerGetInfo(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkerInfoDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetInfo(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AuthApi.authControllerGetInfo']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Login via Hub
     * @param {HubLoginRequestDto} hubLoginRequestDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerHubLogin(
      hubLoginRequestDto: HubLoginRequestDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerHubLogin(hubLoginRequestDto, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AuthApi.authControllerHubLogin']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerLogout(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AuthApi.authControllerLogout']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerMe(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerMe(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AuthApi.authControllerMe']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authControllerRefresh(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1AuthApi.authControllerRefresh']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1AuthApi - factory interface
 * @export
 */
export const ApiV1AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ApiV1AuthApiFp(configuration);
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerGetInfo(options?: RawAxiosRequestConfig): AxiosPromise<WorkerInfoDto> {
      return localVarFp.authControllerGetInfo(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Login via Hub
     * @param {ApiV1AuthApiAuthControllerHubLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerHubLogin(
      requestParameters: ApiV1AuthApiAuthControllerHubLoginRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .authControllerHubLogin(requestParameters.hubLoginRequestDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerMe(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.authControllerMe(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authControllerRefresh(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.authControllerRefresh(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1AuthApi - interface
 * @export
 * @interface ApiV1AuthApi
 */
export interface ApiV1AuthApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApiInterface
   */
  authControllerGetInfo(options?: RawAxiosRequestConfig): AxiosPromise<WorkerInfoDto>;

  /**
   *
   * @summary Login via Hub
   * @param {ApiV1AuthApiAuthControllerHubLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApiInterface
   */
  authControllerHubLogin(
    requestParameters: ApiV1AuthApiAuthControllerHubLoginRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApiInterface
   */
  authControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApiInterface
   */
  authControllerMe(options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApiInterface
   */
  authControllerRefresh(options?: RawAxiosRequestConfig): AxiosPromise<void>;
}

/**
 * Request parameters for authControllerHubLogin operation in ApiV1AuthApi.
 * @export
 * @interface ApiV1AuthApiAuthControllerHubLoginRequest
 */
export interface ApiV1AuthApiAuthControllerHubLoginRequest {
  /**
   *
   * @type {HubLoginRequestDto}
   * @memberof ApiV1AuthApiAuthControllerHubLogin
   */
  readonly hubLoginRequestDto: HubLoginRequestDto;
}

/**
 * ApiV1AuthApi - object-oriented interface
 * @export
 * @class ApiV1AuthApi
 * @extends {BaseAPI}
 */
export class ApiV1AuthApi extends BaseAPI implements ApiV1AuthApiInterface {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApi
   */
  public authControllerGetInfo(options?: RawAxiosRequestConfig) {
    return ApiV1AuthApiFp(this.configuration)
      .authControllerGetInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Login via Hub
   * @param {ApiV1AuthApiAuthControllerHubLoginRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApi
   */
  public authControllerHubLogin(
    requestParameters: ApiV1AuthApiAuthControllerHubLoginRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1AuthApiFp(this.configuration)
      .authControllerHubLogin(requestParameters.hubLoginRequestDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApi
   */
  public authControllerLogout(options?: RawAxiosRequestConfig) {
    return ApiV1AuthApiFp(this.configuration)
      .authControllerLogout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApi
   */
  public authControllerMe(options?: RawAxiosRequestConfig) {
    return ApiV1AuthApiFp(this.configuration)
      .authControllerMe(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1AuthApi
   */
  public authControllerRefresh(options?: RawAxiosRequestConfig) {
    return ApiV1AuthApiFp(this.configuration)
      .authControllerRefresh(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1ConfigApi - axios parameter creator
 * @export
 */
export const ApiV1ConfigApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the full config of a specific pipeline by name
     * @param {string} workspaceBlockName The config key of the workspace type
     * @param {string} pipelineName The name of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetPipelineConfigByName: async (
      workspaceBlockName: string,
      pipelineName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceBlockName' is not null or undefined
      assertParamExists('configControllerGetPipelineConfigByName', 'workspaceBlockName', workspaceBlockName);
      // verify required parameter 'pipelineName' is not null or undefined
      assertParamExists('configControllerGetPipelineConfigByName', 'pipelineName', pipelineName);
      const localVarPath = `/api/v1/config/workspaces/{workspaceBlockName}/pipelines/{pipelineName}`
        .replace(`{${'workspaceBlockName'}}`, encodeURIComponent(String(workspaceBlockName)))
        .replace(`{${'pipelineName'}}`, encodeURIComponent(String(pipelineName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the source config of a specific pipeline by name
     * @param {string} workspaceBlockName The config key of the workspace type
     * @param {string} pipelineName The name of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetPipelineSourceByName: async (
      workspaceBlockName: string,
      pipelineName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceBlockName' is not null or undefined
      assertParamExists('configControllerGetPipelineSourceByName', 'workspaceBlockName', workspaceBlockName);
      // verify required parameter 'pipelineName' is not null or undefined
      assertParamExists('configControllerGetPipelineSourceByName', 'pipelineName', pipelineName);
      const localVarPath = `/api/v1/config/workspaces/{workspaceBlockName}/pipelines/{pipelineName}/source`
        .replace(`{${'workspaceBlockName'}}`, encodeURIComponent(String(workspaceBlockName)))
        .replace(`{${'pipelineName'}}`, encodeURIComponent(String(pipelineName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all pipeline types available for this workspace
     * @param {string} workspaceBlockName The config key of the workspace type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetPipelineTypesByWorkspace: async (
      workspaceBlockName: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceBlockName' is not null or undefined
      assertParamExists('configControllerGetPipelineTypesByWorkspace', 'workspaceBlockName', workspaceBlockName);
      const localVarPath = `/api/v1/config/workspaces/{workspaceBlockName}/pipelines`.replace(
        `{${'workspaceBlockName'}}`,
        encodeURIComponent(String(workspaceBlockName)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all models available for this workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetWorkspaceTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/config/workspaces`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1ConfigApi - functional programming interface
 * @export
 */
export const ApiV1ConfigApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1ConfigApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get the full config of a specific pipeline by name
     * @param {string} workspaceBlockName The config key of the workspace type
     * @param {string} pipelineName The name of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async configControllerGetPipelineConfigByName(
      workspaceBlockName: string,
      pipelineName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineConfigDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.configControllerGetPipelineConfigByName(
        workspaceBlockName,
        pipelineName,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1ConfigApi.configControllerGetPipelineConfigByName']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the source config of a specific pipeline by name
     * @param {string} workspaceBlockName The config key of the workspace type
     * @param {string} pipelineName The name of the pipeline to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async configControllerGetPipelineSourceByName(
      workspaceBlockName: string,
      pipelineName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineSourceDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.configControllerGetPipelineSourceByName(
        workspaceBlockName,
        pipelineName,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1ConfigApi.configControllerGetPipelineSourceByName']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all pipeline types available for this workspace
     * @param {string} workspaceBlockName The config key of the workspace type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async configControllerGetPipelineTypesByWorkspace(
      workspaceBlockName: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PipelineConfigDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.configControllerGetPipelineTypesByWorkspace(
        workspaceBlockName,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1ConfigApi.configControllerGetPipelineTypesByWorkspace']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all models available for this workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async configControllerGetWorkspaceTypes(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceConfigDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.configControllerGetWorkspaceTypes(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1ConfigApi.configControllerGetWorkspaceTypes']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1ConfigApi - factory interface
 * @export
 */
export const ApiV1ConfigApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1ConfigApiFp(configuration);
  return {
    /**
     *
     * @summary Get the full config of a specific pipeline by name
     * @param {ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetPipelineConfigByName(
      requestParameters: ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PipelineConfigDto> {
      return localVarFp
        .configControllerGetPipelineConfigByName(
          requestParameters.workspaceBlockName,
          requestParameters.pipelineName,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the source config of a specific pipeline by name
     * @param {ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetPipelineSourceByName(
      requestParameters: ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PipelineSourceDto> {
      return localVarFp
        .configControllerGetPipelineSourceByName(
          requestParameters.workspaceBlockName,
          requestParameters.pipelineName,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all pipeline types available for this workspace
     * @param {ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetPipelineTypesByWorkspace(
      requestParameters: ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<PipelineConfigDto>> {
      return localVarFp
        .configControllerGetPipelineTypesByWorkspace(requestParameters.workspaceBlockName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all models available for this workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    configControllerGetWorkspaceTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceConfigDto>> {
      return localVarFp.configControllerGetWorkspaceTypes(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1ConfigApi - interface
 * @export
 * @interface ApiV1ConfigApi
 */
export interface ApiV1ConfigApiInterface {
  /**
   *
   * @summary Get the full config of a specific pipeline by name
   * @param {ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApiInterface
   */
  configControllerGetPipelineConfigByName(
    requestParameters: ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PipelineConfigDto>;

  /**
   *
   * @summary Get the source config of a specific pipeline by name
   * @param {ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApiInterface
   */
  configControllerGetPipelineSourceByName(
    requestParameters: ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PipelineSourceDto>;

  /**
   *
   * @summary Get all pipeline types available for this workspace
   * @param {ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApiInterface
   */
  configControllerGetPipelineTypesByWorkspace(
    requestParameters: ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<PipelineConfigDto>>;

  /**
   *
   * @summary Get all models available for this workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApiInterface
   */
  configControllerGetWorkspaceTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceConfigDto>>;
}

/**
 * Request parameters for configControllerGetPipelineConfigByName operation in ApiV1ConfigApi.
 * @export
 * @interface ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest
 */
export interface ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest {
  /**
   * The config key of the workspace type
   * @type {string}
   * @memberof ApiV1ConfigApiConfigControllerGetPipelineConfigByName
   */
  readonly workspaceBlockName: string;

  /**
   * The name of the pipeline to retrieve
   * @type {string}
   * @memberof ApiV1ConfigApiConfigControllerGetPipelineConfigByName
   */
  readonly pipelineName: string;
}

/**
 * Request parameters for configControllerGetPipelineSourceByName operation in ApiV1ConfigApi.
 * @export
 * @interface ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest
 */
export interface ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest {
  /**
   * The config key of the workspace type
   * @type {string}
   * @memberof ApiV1ConfigApiConfigControllerGetPipelineSourceByName
   */
  readonly workspaceBlockName: string;

  /**
   * The name of the pipeline to retrieve
   * @type {string}
   * @memberof ApiV1ConfigApiConfigControllerGetPipelineSourceByName
   */
  readonly pipelineName: string;
}

/**
 * Request parameters for configControllerGetPipelineTypesByWorkspace operation in ApiV1ConfigApi.
 * @export
 * @interface ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest
 */
export interface ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest {
  /**
   * The config key of the workspace type
   * @type {string}
   * @memberof ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspace
   */
  readonly workspaceBlockName: string;
}

/**
 * ApiV1ConfigApi - object-oriented interface
 * @export
 * @class ApiV1ConfigApi
 * @extends {BaseAPI}
 */
export class ApiV1ConfigApi extends BaseAPI implements ApiV1ConfigApiInterface {
  /**
   *
   * @summary Get the full config of a specific pipeline by name
   * @param {ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApi
   */
  public configControllerGetPipelineConfigByName(
    requestParameters: ApiV1ConfigApiConfigControllerGetPipelineConfigByNameRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1ConfigApiFp(this.configuration)
      .configControllerGetPipelineConfigByName(
        requestParameters.workspaceBlockName,
        requestParameters.pipelineName,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the source config of a specific pipeline by name
   * @param {ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApi
   */
  public configControllerGetPipelineSourceByName(
    requestParameters: ApiV1ConfigApiConfigControllerGetPipelineSourceByNameRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1ConfigApiFp(this.configuration)
      .configControllerGetPipelineSourceByName(
        requestParameters.workspaceBlockName,
        requestParameters.pipelineName,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all pipeline types available for this workspace
   * @param {ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApi
   */
  public configControllerGetPipelineTypesByWorkspace(
    requestParameters: ApiV1ConfigApiConfigControllerGetPipelineTypesByWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1ConfigApiFp(this.configuration)
      .configControllerGetPipelineTypesByWorkspace(requestParameters.workspaceBlockName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all models available for this workspace
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ConfigApi
   */
  public configControllerGetWorkspaceTypes(options?: RawAxiosRequestConfig) {
    return ApiV1ConfigApiFp(this.configuration)
      .configControllerGetWorkspaceTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1DashboardApi - axios parameter creator
 * @export
 */
export const ApiV1DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieves aggregated statistics for all automations across all workspaces
     * @summary Get dashboard statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardControllerGetDashboardStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/dashboard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1DashboardApi - functional programming interface
 * @export
 */
export const ApiV1DashboardApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1DashboardApiAxiosParamCreator(configuration);
  return {
    /**
     * Retrieves aggregated statistics for all automations across all workspaces
     * @summary Get dashboard statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dashboardControllerGetDashboardStats(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardStatsDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.dashboardControllerGetDashboardStats(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1DashboardApi.dashboardControllerGetDashboardStats']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1DashboardApi - factory interface
 * @export
 */
export const ApiV1DashboardApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1DashboardApiFp(configuration);
  return {
    /**
     * Retrieves aggregated statistics for all automations across all workspaces
     * @summary Get dashboard statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dashboardControllerGetDashboardStats(options?: RawAxiosRequestConfig): AxiosPromise<DashboardStatsDto> {
      return localVarFp.dashboardControllerGetDashboardStats(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1DashboardApi - interface
 * @export
 * @interface ApiV1DashboardApi
 */
export interface ApiV1DashboardApiInterface {
  /**
   * Retrieves aggregated statistics for all automations across all workspaces
   * @summary Get dashboard statistics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1DashboardApiInterface
   */
  dashboardControllerGetDashboardStats(options?: RawAxiosRequestConfig): AxiosPromise<DashboardStatsDto>;
}

/**
 * ApiV1DashboardApi - object-oriented interface
 * @export
 * @class ApiV1DashboardApi
 * @extends {BaseAPI}
 */
export class ApiV1DashboardApi extends BaseAPI implements ApiV1DashboardApiInterface {
  /**
   * Retrieves aggregated statistics for all automations across all workspaces
   * @summary Get dashboard statistics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1DashboardApi
   */
  public dashboardControllerGetDashboardStats(options?: RawAxiosRequestConfig) {
    return ApiV1DashboardApiFp(this.configuration)
      .dashboardControllerGetDashboardStats(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1DocumentsApi - axios parameter creator
 * @export
 */
export const ApiV1DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a document by ID
     * @param {string} id The ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentControllerGetDocumentById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('documentControllerGetDocumentById', 'id', id);
      const localVarPath = `/api/v1/documents/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve documents with filters, sorting, and pagination
     * @param {string} [filter] JSON string of DocumentFilterDto object
     * @param {string} [sortBy] JSON string array of DocumentSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentControllerGetDocuments: async (
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/documents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1DocumentsApi - functional programming interface
 * @export
 */
export const ApiV1DocumentsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1DocumentsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get a document by ID
     * @param {string} id The ID of the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async documentControllerGetDocumentById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocumentById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1DocumentsApi.documentControllerGetDocumentById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Retrieve documents with filters, sorting, and pagination
     * @param {string} [filter] JSON string of DocumentFilterDto object
     * @param {string} [sortBy] JSON string array of DocumentSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async documentControllerGetDocuments(
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentControllerGetDocuments200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.documentControllerGetDocuments(
        filter,
        sortBy,
        page,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1DocumentsApi.documentControllerGetDocuments']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1DocumentsApi - factory interface
 * @export
 */
export const ApiV1DocumentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1DocumentsApiFp(configuration);
  return {
    /**
     *
     * @summary Get a document by ID
     * @param {ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentControllerGetDocumentById(
      requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DocumentDto> {
      return localVarFp
        .documentControllerGetDocumentById(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve documents with filters, sorting, and pagination
     * @param {ApiV1DocumentsApiDocumentControllerGetDocumentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    documentControllerGetDocuments(
      requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<DocumentControllerGetDocuments200Response> {
      return localVarFp
        .documentControllerGetDocuments(
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.page,
          requestParameters.limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1DocumentsApi - interface
 * @export
 * @interface ApiV1DocumentsApi
 */
export interface ApiV1DocumentsApiInterface {
  /**
   *
   * @summary Get a document by ID
   * @param {ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1DocumentsApiInterface
   */
  documentControllerGetDocumentById(
    requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<DocumentDto>;

  /**
   *
   * @summary Retrieve documents with filters, sorting, and pagination
   * @param {ApiV1DocumentsApiDocumentControllerGetDocumentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1DocumentsApiInterface
   */
  documentControllerGetDocuments(
    requestParameters?: ApiV1DocumentsApiDocumentControllerGetDocumentsRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<DocumentControllerGetDocuments200Response>;
}

/**
 * Request parameters for documentControllerGetDocumentById operation in ApiV1DocumentsApi.
 * @export
 * @interface ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest
 */
export interface ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest {
  /**
   * The ID of the document
   * @type {string}
   * @memberof ApiV1DocumentsApiDocumentControllerGetDocumentById
   */
  readonly id: string;
}

/**
 * Request parameters for documentControllerGetDocuments operation in ApiV1DocumentsApi.
 * @export
 * @interface ApiV1DocumentsApiDocumentControllerGetDocumentsRequest
 */
export interface ApiV1DocumentsApiDocumentControllerGetDocumentsRequest {
  /**
   * JSON string of DocumentFilterDto object
   * @type {string}
   * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
   */
  readonly filter?: string;

  /**
   * JSON string array of DocumentSortByDto objects
   * @type {string}
   * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
   */
  readonly sortBy?: string;

  /**
   * Page number for pagination (starts at 1)
   * @type {number}
   * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ApiV1DocumentsApiDocumentControllerGetDocuments
   */
  readonly limit?: number;
}

/**
 * ApiV1DocumentsApi - object-oriented interface
 * @export
 * @class ApiV1DocumentsApi
 * @extends {BaseAPI}
 */
export class ApiV1DocumentsApi extends BaseAPI implements ApiV1DocumentsApiInterface {
  /**
   *
   * @summary Get a document by ID
   * @param {ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1DocumentsApi
   */
  public documentControllerGetDocumentById(
    requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1DocumentsApiFp(this.configuration)
      .documentControllerGetDocumentById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve documents with filters, sorting, and pagination
   * @param {ApiV1DocumentsApiDocumentControllerGetDocumentsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1DocumentsApi
   */
  public documentControllerGetDocuments(
    requestParameters: ApiV1DocumentsApiDocumentControllerGetDocumentsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1DocumentsApiFp(this.configuration)
      .documentControllerGetDocuments(
        requestParameters.filter,
        requestParameters.sortBy,
        requestParameters.page,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1NamespacesApi - axios parameter creator
 * @export
 */
export const ApiV1NamespacesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a namespace by ID
     * @param {string} id The ID of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    namespaceControllerGetWorkflowById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('namespaceControllerGetWorkflowById', 'id', id);
      const localVarPath = `/api/v1/namespaces/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve namespaces with filters, sorting, and pagination
     * @param {string} [filter] JSON string of NamespaceFilterDto object
     * @param {string} [sortBy] JSON string array of NamespaceSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    namespaceControllerGetWorkflows: async (
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/namespaces`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1NamespacesApi - functional programming interface
 * @export
 */
export const ApiV1NamespacesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1NamespacesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get a namespace by ID
     * @param {string} id The ID of the namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async namespaceControllerGetWorkflowById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamespaceDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.namespaceControllerGetWorkflowById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1NamespacesApi.namespaceControllerGetWorkflowById']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Retrieve namespaces with filters, sorting, and pagination
     * @param {string} [filter] JSON string of NamespaceFilterDto object
     * @param {string} [sortBy] JSON string array of NamespaceSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async namespaceControllerGetWorkflows(
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NamespaceControllerGetWorkflows200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.namespaceControllerGetWorkflows(
        filter,
        sortBy,
        page,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1NamespacesApi.namespaceControllerGetWorkflows']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1NamespacesApi - factory interface
 * @export
 */
export const ApiV1NamespacesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1NamespacesApiFp(configuration);
  return {
    /**
     *
     * @summary Get a namespace by ID
     * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    namespaceControllerGetWorkflowById(
      requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<NamespaceDto> {
      return localVarFp
        .namespaceControllerGetWorkflowById(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve namespaces with filters, sorting, and pagination
     * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    namespaceControllerGetWorkflows(
      requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<NamespaceControllerGetWorkflows200Response> {
      return localVarFp
        .namespaceControllerGetWorkflows(
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.page,
          requestParameters.limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1NamespacesApi - interface
 * @export
 * @interface ApiV1NamespacesApi
 */
export interface ApiV1NamespacesApiInterface {
  /**
   *
   * @summary Get a namespace by ID
   * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1NamespacesApiInterface
   */
  namespaceControllerGetWorkflowById(
    requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<NamespaceDto>;

  /**
   *
   * @summary Retrieve namespaces with filters, sorting, and pagination
   * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1NamespacesApiInterface
   */
  namespaceControllerGetWorkflows(
    requestParameters?: ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<NamespaceControllerGetWorkflows200Response>;
}

/**
 * Request parameters for namespaceControllerGetWorkflowById operation in ApiV1NamespacesApi.
 * @export
 * @interface ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest
 */
export interface ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest {
  /**
   * The ID of the namespace
   * @type {string}
   * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflowById
   */
  readonly id: string;
}

/**
 * Request parameters for namespaceControllerGetWorkflows operation in ApiV1NamespacesApi.
 * @export
 * @interface ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest
 */
export interface ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest {
  /**
   * JSON string of NamespaceFilterDto object
   * @type {string}
   * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
   */
  readonly filter?: string;

  /**
   * JSON string array of NamespaceSortByDto objects
   * @type {string}
   * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
   */
  readonly sortBy?: string;

  /**
   * Page number for pagination (starts at 1)
   * @type {number}
   * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ApiV1NamespacesApiNamespaceControllerGetWorkflows
   */
  readonly limit?: number;
}

/**
 * ApiV1NamespacesApi - object-oriented interface
 * @export
 * @class ApiV1NamespacesApi
 * @extends {BaseAPI}
 */
export class ApiV1NamespacesApi extends BaseAPI implements ApiV1NamespacesApiInterface {
  /**
   *
   * @summary Get a namespace by ID
   * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1NamespacesApi
   */
  public namespaceControllerGetWorkflowById(
    requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1NamespacesApiFp(this.configuration)
      .namespaceControllerGetWorkflowById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve namespaces with filters, sorting, and pagination
   * @param {ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1NamespacesApi
   */
  public namespaceControllerGetWorkflows(
    requestParameters: ApiV1NamespacesApiNamespaceControllerGetWorkflowsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1NamespacesApiFp(this.configuration)
      .namespaceControllerGetWorkflows(
        requestParameters.filter,
        requestParameters.sortBy,
        requestParameters.page,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1PipelinesApi - axios parameter creator
 * @export
 */
export const ApiV1PipelinesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns the content of a specific file in the pipeline\'s workspace
     * @summary Get file content
     * @param {string} pipelineId The unique identifier of the pipeline
     * @param {string} filePath File path relative to workspace root (URL encoded, supports nested paths)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileControllerGetFileContent: async (
      pipelineId: string,
      filePath: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'pipelineId' is not null or undefined
      assertParamExists('fileControllerGetFileContent', 'pipelineId', pipelineId);
      // verify required parameter 'filePath' is not null or undefined
      assertParamExists('fileControllerGetFileContent', 'filePath', filePath);
      const localVarPath = `/api/v1/pipelines/{pipelineId}/files/{filePath}`
        .replace(`{${'pipelineId'}}`, encodeURIComponent(String(pipelineId)))
        .replace(`{${'filePath'}}`, encodeURIComponent(String(filePath)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the file tree structure of files in the pipeline\'s workspace directory
     * @summary Get file tree for a pipeline
     * @param {string} pipelineId The unique identifier of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileControllerGetFileTree: async (
      pipelineId: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'pipelineId' is not null or undefined
      assertParamExists('fileControllerGetFileTree', 'pipelineId', pipelineId);
      const localVarPath = `/api/v1/pipelines/{pipelineId}/files`.replace(
        `{${'pipelineId'}}`,
        encodeURIComponent(String(pipelineId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete multiple pipelines by IDs
     * @param {PipelineControllerBatchDeletePipelinesRequest} pipelineControllerBatchDeletePipelinesRequest Array of pipeline IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerBatchDeletePipelines: async (
      pipelineControllerBatchDeletePipelinesRequest: PipelineControllerBatchDeletePipelinesRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'pipelineControllerBatchDeletePipelinesRequest' is not null or undefined
      assertParamExists(
        'pipelineControllerBatchDeletePipelines',
        'pipelineControllerBatchDeletePipelinesRequest',
        pipelineControllerBatchDeletePipelinesRequest,
      );
      const localVarPath = `/api/v1/pipelines/batch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        pipelineControllerBatchDeletePipelinesRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new pipeline
     * @param {PipelineCreateDto} pipelineCreateDto Pipeline data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerCreatePipeline: async (
      pipelineCreateDto: PipelineCreateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'pipelineCreateDto' is not null or undefined
      assertParamExists('pipelineControllerCreatePipeline', 'pipelineCreateDto', pipelineCreateDto);
      const localVarPath = `/api/v1/pipelines`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(pipelineCreateDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a pipeline by ID
     * @param {string} id The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerDeletePipeline: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pipelineControllerDeletePipeline', 'id', id);
      const localVarPath = `/api/v1/pipelines/id/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a pipeline by ID
     * @param {string} id The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerGetPipelineById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pipelineControllerGetPipelineById', 'id', id);
      const localVarPath = `/api/v1/pipelines/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve pipelines with filters, sorting, pagination, and search
     * @param {string} [filter] JSON string of PipelineFilterDto object
     * @param {string} [sortBy] JSON string array of PipelineSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter workspaces by title or other searchable fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerGetPipelines: async (
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      search?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/pipelines`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a pipeline by ID
     * @param {string} id The ID of the pipeline
     * @param {PipelineUpdateDto} pipelineUpdateDto Updated pipeline data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerUpdatePipeline: async (
      id: string,
      pipelineUpdateDto: PipelineUpdateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('pipelineControllerUpdatePipeline', 'id', id);
      // verify required parameter 'pipelineUpdateDto' is not null or undefined
      assertParamExists('pipelineControllerUpdatePipeline', 'pipelineUpdateDto', pipelineUpdateDto);
      const localVarPath = `/api/v1/pipelines/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(pipelineUpdateDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1PipelinesApi - functional programming interface
 * @export
 */
export const ApiV1PipelinesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1PipelinesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the content of a specific file in the pipeline\'s workspace
     * @summary Get file content
     * @param {string} pipelineId The unique identifier of the pipeline
     * @param {string} filePath File path relative to workspace root (URL encoded, supports nested paths)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileControllerGetFileContent(
      pipelineId: string,
      filePath: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileContentDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileControllerGetFileContent(
        pipelineId,
        filePath,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.fileControllerGetFileContent']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Returns the file tree structure of files in the pipeline\'s workspace directory
     * @summary Get file tree for a pipeline
     * @param {string} pipelineId The unique identifier of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileControllerGetFileTree(
      pipelineId: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileExplorerNodeDto>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileControllerGetFileTree(pipelineId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.fileControllerGetFileTree']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete multiple pipelines by IDs
     * @param {PipelineControllerBatchDeletePipelinesRequest} pipelineControllerBatchDeletePipelinesRequest Array of pipeline IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pipelineControllerBatchDeletePipelines(
      pipelineControllerBatchDeletePipelinesRequest: PipelineControllerBatchDeletePipelinesRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineControllerBatchDeletePipelines200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerBatchDeletePipelines(
        pipelineControllerBatchDeletePipelinesRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.pipelineControllerBatchDeletePipelines']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create a new pipeline
     * @param {PipelineCreateDto} pipelineCreateDto Pipeline data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pipelineControllerCreatePipeline(
      pipelineCreateDto: PipelineCreateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerCreatePipeline(
        pipelineCreateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.pipelineControllerCreatePipeline']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a pipeline by ID
     * @param {string} id The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pipelineControllerDeletePipeline(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerDeletePipeline(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.pipelineControllerDeletePipeline']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a pipeline by ID
     * @param {string} id The ID of the pipeline
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pipelineControllerGetPipelineById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerGetPipelineById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.pipelineControllerGetPipelineById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Retrieve pipelines with filters, sorting, pagination, and search
     * @param {string} [filter] JSON string of PipelineFilterDto object
     * @param {string} [sortBy] JSON string array of PipelineSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter workspaces by title or other searchable fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pipelineControllerGetPipelines(
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      search?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineControllerGetPipelines200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerGetPipelines(
        filter,
        sortBy,
        page,
        limit,
        search,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.pipelineControllerGetPipelines']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update a pipeline by ID
     * @param {string} id The ID of the pipeline
     * @param {PipelineUpdateDto} pipelineUpdateDto Updated pipeline data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pipelineControllerUpdatePipeline(
      id: string,
      pipelineUpdateDto: PipelineUpdateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PipelineDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pipelineControllerUpdatePipeline(
        id,
        pipelineUpdateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1PipelinesApi.pipelineControllerUpdatePipeline']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1PipelinesApi - factory interface
 * @export
 */
export const ApiV1PipelinesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1PipelinesApiFp(configuration);
  return {
    /**
     * Returns the content of a specific file in the pipeline\'s workspace
     * @summary Get file content
     * @param {ApiV1PipelinesApiFileControllerGetFileContentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileControllerGetFileContent(
      requestParameters: ApiV1PipelinesApiFileControllerGetFileContentRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<FileContentDto> {
      return localVarFp
        .fileControllerGetFileContent(requestParameters.pipelineId, requestParameters.filePath, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the file tree structure of files in the pipeline\'s workspace directory
     * @summary Get file tree for a pipeline
     * @param {ApiV1PipelinesApiFileControllerGetFileTreeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileControllerGetFileTree(
      requestParameters: ApiV1PipelinesApiFileControllerGetFileTreeRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<Array<FileExplorerNodeDto>> {
      return localVarFp
        .fileControllerGetFileTree(requestParameters.pipelineId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete multiple pipelines by IDs
     * @param {ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerBatchDeletePipelines(
      requestParameters: ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PipelineControllerBatchDeletePipelines200Response> {
      return localVarFp
        .pipelineControllerBatchDeletePipelines(
          requestParameters.pipelineControllerBatchDeletePipelinesRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new pipeline
     * @param {ApiV1PipelinesApiPipelineControllerCreatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerCreatePipeline(
      requestParameters: ApiV1PipelinesApiPipelineControllerCreatePipelineRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PipelineDto> {
      return localVarFp
        .pipelineControllerCreatePipeline(requestParameters.pipelineCreateDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerDeletePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerDeletePipeline(
      requestParameters: ApiV1PipelinesApiPipelineControllerDeletePipelineRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .pipelineControllerDeletePipeline(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerGetPipelineById(
      requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PipelineDto> {
      return localVarFp
        .pipelineControllerGetPipelineById(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve pipelines with filters, sorting, pagination, and search
     * @param {ApiV1PipelinesApiPipelineControllerGetPipelinesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerGetPipelines(
      requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelinesRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PipelineControllerGetPipelines200Response> {
      return localVarFp
        .pipelineControllerGetPipelines(
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.page,
          requestParameters.limit,
          requestParameters.search,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a pipeline by ID
     * @param {ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pipelineControllerUpdatePipeline(
      requestParameters: ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<PipelineDto> {
      return localVarFp
        .pipelineControllerUpdatePipeline(requestParameters.id, requestParameters.pipelineUpdateDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1PipelinesApi - interface
 * @export
 * @interface ApiV1PipelinesApi
 */
export interface ApiV1PipelinesApiInterface {
  /**
   * Returns the content of a specific file in the pipeline\'s workspace
   * @summary Get file content
   * @param {ApiV1PipelinesApiFileControllerGetFileContentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  fileControllerGetFileContent(
    requestParameters: ApiV1PipelinesApiFileControllerGetFileContentRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<FileContentDto>;

  /**
   * Returns the file tree structure of files in the pipeline\'s workspace directory
   * @summary Get file tree for a pipeline
   * @param {ApiV1PipelinesApiFileControllerGetFileTreeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  fileControllerGetFileTree(
    requestParameters: ApiV1PipelinesApiFileControllerGetFileTreeRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<Array<FileExplorerNodeDto>>;

  /**
   *
   * @summary Delete multiple pipelines by IDs
   * @param {ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  pipelineControllerBatchDeletePipelines(
    requestParameters: ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PipelineControllerBatchDeletePipelines200Response>;

  /**
   *
   * @summary Create a new pipeline
   * @param {ApiV1PipelinesApiPipelineControllerCreatePipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  pipelineControllerCreatePipeline(
    requestParameters: ApiV1PipelinesApiPipelineControllerCreatePipelineRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PipelineDto>;

  /**
   *
   * @summary Delete a pipeline by ID
   * @param {ApiV1PipelinesApiPipelineControllerDeletePipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  pipelineControllerDeletePipeline(
    requestParameters: ApiV1PipelinesApiPipelineControllerDeletePipelineRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get a pipeline by ID
   * @param {ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  pipelineControllerGetPipelineById(
    requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PipelineDto>;

  /**
   *
   * @summary Retrieve pipelines with filters, sorting, pagination, and search
   * @param {ApiV1PipelinesApiPipelineControllerGetPipelinesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  pipelineControllerGetPipelines(
    requestParameters?: ApiV1PipelinesApiPipelineControllerGetPipelinesRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PipelineControllerGetPipelines200Response>;

  /**
   *
   * @summary Update a pipeline by ID
   * @param {ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApiInterface
   */
  pipelineControllerUpdatePipeline(
    requestParameters: ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<PipelineDto>;
}

/**
 * Request parameters for fileControllerGetFileContent operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiFileControllerGetFileContentRequest
 */
export interface ApiV1PipelinesApiFileControllerGetFileContentRequest {
  /**
   * The unique identifier of the pipeline
   * @type {string}
   * @memberof ApiV1PipelinesApiFileControllerGetFileContent
   */
  readonly pipelineId: string;

  /**
   * File path relative to workspace root (URL encoded, supports nested paths)
   * @type {string}
   * @memberof ApiV1PipelinesApiFileControllerGetFileContent
   */
  readonly filePath: string;
}

/**
 * Request parameters for fileControllerGetFileTree operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiFileControllerGetFileTreeRequest
 */
export interface ApiV1PipelinesApiFileControllerGetFileTreeRequest {
  /**
   * The unique identifier of the pipeline
   * @type {string}
   * @memberof ApiV1PipelinesApiFileControllerGetFileTree
   */
  readonly pipelineId: string;
}

/**
 * Request parameters for pipelineControllerBatchDeletePipelines operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest
 */
export interface ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest {
  /**
   * Array of pipeline IDs to delete
   * @type {PipelineControllerBatchDeletePipelinesRequest}
   * @memberof ApiV1PipelinesApiPipelineControllerBatchDeletePipelines
   */
  readonly pipelineControllerBatchDeletePipelinesRequest: PipelineControllerBatchDeletePipelinesRequest;
}

/**
 * Request parameters for pipelineControllerCreatePipeline operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerCreatePipelineRequest
 */
export interface ApiV1PipelinesApiPipelineControllerCreatePipelineRequest {
  /**
   * Pipeline data
   * @type {PipelineCreateDto}
   * @memberof ApiV1PipelinesApiPipelineControllerCreatePipeline
   */
  readonly pipelineCreateDto: PipelineCreateDto;
}

/**
 * Request parameters for pipelineControllerDeletePipeline operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerDeletePipelineRequest
 */
export interface ApiV1PipelinesApiPipelineControllerDeletePipelineRequest {
  /**
   * The ID of the pipeline
   * @type {string}
   * @memberof ApiV1PipelinesApiPipelineControllerDeletePipeline
   */
  readonly id: string;
}

/**
 * Request parameters for pipelineControllerGetPipelineById operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest
 */
export interface ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest {
  /**
   * The ID of the pipeline
   * @type {string}
   * @memberof ApiV1PipelinesApiPipelineControllerGetPipelineById
   */
  readonly id: string;
}

/**
 * Request parameters for pipelineControllerGetPipelines operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerGetPipelinesRequest
 */
export interface ApiV1PipelinesApiPipelineControllerGetPipelinesRequest {
  /**
   * JSON string of PipelineFilterDto object
   * @type {string}
   * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
   */
  readonly filter?: string;

  /**
   * JSON string array of PipelineSortByDto objects
   * @type {string}
   * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
   */
  readonly sortBy?: string;

  /**
   * Page number for pagination (starts at 1)
   * @type {number}
   * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
   */
  readonly limit?: number;

  /**
   * Search term to filter workspaces by title or other searchable fields
   * @type {string}
   * @memberof ApiV1PipelinesApiPipelineControllerGetPipelines
   */
  readonly search?: string;
}

/**
 * Request parameters for pipelineControllerUpdatePipeline operation in ApiV1PipelinesApi.
 * @export
 * @interface ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest
 */
export interface ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest {
  /**
   * The ID of the pipeline
   * @type {string}
   * @memberof ApiV1PipelinesApiPipelineControllerUpdatePipeline
   */
  readonly id: string;

  /**
   * Updated pipeline data
   * @type {PipelineUpdateDto}
   * @memberof ApiV1PipelinesApiPipelineControllerUpdatePipeline
   */
  readonly pipelineUpdateDto: PipelineUpdateDto;
}

/**
 * ApiV1PipelinesApi - object-oriented interface
 * @export
 * @class ApiV1PipelinesApi
 * @extends {BaseAPI}
 */
export class ApiV1PipelinesApi extends BaseAPI implements ApiV1PipelinesApiInterface {
  /**
   * Returns the content of a specific file in the pipeline\'s workspace
   * @summary Get file content
   * @param {ApiV1PipelinesApiFileControllerGetFileContentRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public fileControllerGetFileContent(
    requestParameters: ApiV1PipelinesApiFileControllerGetFileContentRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .fileControllerGetFileContent(requestParameters.pipelineId, requestParameters.filePath, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the file tree structure of files in the pipeline\'s workspace directory
   * @summary Get file tree for a pipeline
   * @param {ApiV1PipelinesApiFileControllerGetFileTreeRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public fileControllerGetFileTree(
    requestParameters: ApiV1PipelinesApiFileControllerGetFileTreeRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .fileControllerGetFileTree(requestParameters.pipelineId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete multiple pipelines by IDs
   * @param {ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public pipelineControllerBatchDeletePipelines(
    requestParameters: ApiV1PipelinesApiPipelineControllerBatchDeletePipelinesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .pipelineControllerBatchDeletePipelines(requestParameters.pipelineControllerBatchDeletePipelinesRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new pipeline
   * @param {ApiV1PipelinesApiPipelineControllerCreatePipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public pipelineControllerCreatePipeline(
    requestParameters: ApiV1PipelinesApiPipelineControllerCreatePipelineRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .pipelineControllerCreatePipeline(requestParameters.pipelineCreateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a pipeline by ID
   * @param {ApiV1PipelinesApiPipelineControllerDeletePipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public pipelineControllerDeletePipeline(
    requestParameters: ApiV1PipelinesApiPipelineControllerDeletePipelineRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .pipelineControllerDeletePipeline(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a pipeline by ID
   * @param {ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public pipelineControllerGetPipelineById(
    requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelineByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .pipelineControllerGetPipelineById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve pipelines with filters, sorting, pagination, and search
   * @param {ApiV1PipelinesApiPipelineControllerGetPipelinesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public pipelineControllerGetPipelines(
    requestParameters: ApiV1PipelinesApiPipelineControllerGetPipelinesRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .pipelineControllerGetPipelines(
        requestParameters.filter,
        requestParameters.sortBy,
        requestParameters.page,
        requestParameters.limit,
        requestParameters.search,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a pipeline by ID
   * @param {ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1PipelinesApi
   */
  public pipelineControllerUpdatePipeline(
    requestParameters: ApiV1PipelinesApiPipelineControllerUpdatePipelineRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1PipelinesApiFp(this.configuration)
      .pipelineControllerUpdatePipeline(requestParameters.id, requestParameters.pipelineUpdateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1ProcessorApi - axios parameter creator
 * @export
 */
export const ApiV1ProcessorApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Triggers the processing of a pipeline with the given ID and configuration
     * @summary Run a pipeline
     * @param {string} pipelineId The unique identifier of the pipeline to run
     * @param {RunPipelinePayloadDto} runPipelinePayloadDto Configuration and parameters for the pipeline run
     * @param {boolean} [force] When true, forces the pipeline to run even if locked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processorControllerRunPipeline: async (
      pipelineId: string,
      runPipelinePayloadDto: RunPipelinePayloadDto,
      force?: boolean,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'pipelineId' is not null or undefined
      assertParamExists('processorControllerRunPipeline', 'pipelineId', pipelineId);
      // verify required parameter 'runPipelinePayloadDto' is not null or undefined
      assertParamExists('processorControllerRunPipeline', 'runPipelinePayloadDto', runPipelinePayloadDto);
      const localVarPath = `/api/v1/processor/run/{pipelineId}`.replace(
        `{${'pipelineId'}}`,
        encodeURIComponent(String(pipelineId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (force !== undefined) {
        localVarQueryParameter['force'] = force;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(runPipelinePayloadDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1ProcessorApi - functional programming interface
 * @export
 */
export const ApiV1ProcessorApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1ProcessorApiAxiosParamCreator(configuration);
  return {
    /**
     * Triggers the processing of a pipeline with the given ID and configuration
     * @summary Run a pipeline
     * @param {string} pipelineId The unique identifier of the pipeline to run
     * @param {RunPipelinePayloadDto} runPipelinePayloadDto Configuration and parameters for the pipeline run
     * @param {boolean} [force] When true, forces the pipeline to run even if locked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async processorControllerRunPipeline(
      pipelineId: string,
      runPipelinePayloadDto: RunPipelinePayloadDto,
      force?: boolean,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.processorControllerRunPipeline(
        pipelineId,
        runPipelinePayloadDto,
        force,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1ProcessorApi.processorControllerRunPipeline']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1ProcessorApi - factory interface
 * @export
 */
export const ApiV1ProcessorApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1ProcessorApiFp(configuration);
  return {
    /**
     * Triggers the processing of a pipeline with the given ID and configuration
     * @summary Run a pipeline
     * @param {ApiV1ProcessorApiProcessorControllerRunPipelineRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    processorControllerRunPipeline(
      requestParameters: ApiV1ProcessorApiProcessorControllerRunPipelineRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .processorControllerRunPipeline(
          requestParameters.pipelineId,
          requestParameters.runPipelinePayloadDto,
          requestParameters.force,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1ProcessorApi - interface
 * @export
 * @interface ApiV1ProcessorApi
 */
export interface ApiV1ProcessorApiInterface {
  /**
   * Triggers the processing of a pipeline with the given ID and configuration
   * @summary Run a pipeline
   * @param {ApiV1ProcessorApiProcessorControllerRunPipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ProcessorApiInterface
   */
  processorControllerRunPipeline(
    requestParameters: ApiV1ProcessorApiProcessorControllerRunPipelineRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;
}

/**
 * Request parameters for processorControllerRunPipeline operation in ApiV1ProcessorApi.
 * @export
 * @interface ApiV1ProcessorApiProcessorControllerRunPipelineRequest
 */
export interface ApiV1ProcessorApiProcessorControllerRunPipelineRequest {
  /**
   * The unique identifier of the pipeline to run
   * @type {string}
   * @memberof ApiV1ProcessorApiProcessorControllerRunPipeline
   */
  readonly pipelineId: string;

  /**
   * Configuration and parameters for the pipeline run
   * @type {RunPipelinePayloadDto}
   * @memberof ApiV1ProcessorApiProcessorControllerRunPipeline
   */
  readonly runPipelinePayloadDto: RunPipelinePayloadDto;

  /**
   * When true, forces the pipeline to run even if locked
   * @type {boolean}
   * @memberof ApiV1ProcessorApiProcessorControllerRunPipeline
   */
  readonly force?: boolean;
}

/**
 * ApiV1ProcessorApi - object-oriented interface
 * @export
 * @class ApiV1ProcessorApi
 * @extends {BaseAPI}
 */
export class ApiV1ProcessorApi extends BaseAPI implements ApiV1ProcessorApiInterface {
  /**
   * Triggers the processing of a pipeline with the given ID and configuration
   * @summary Run a pipeline
   * @param {ApiV1ProcessorApiProcessorControllerRunPipelineRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1ProcessorApi
   */
  public processorControllerRunPipeline(
    requestParameters: ApiV1ProcessorApiProcessorControllerRunPipelineRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1ProcessorApiFp(this.configuration)
      .processorControllerRunPipeline(
        requestParameters.pipelineId,
        requestParameters.runPipelinePayloadDto,
        requestParameters.force,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1SseApi - axios parameter creator
 * @export
 */
export const ApiV1SseApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Returns the number of active SSE connections. Requires ADMIN role.
     * @summary SSE health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sseControllerHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/sse/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Establishes a Server-Sent Events connection to receive real-time updates
     * @summary Server-Sent Events stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sseControllerStream: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/sse/stream`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1SseApi - functional programming interface
 * @export
 */
export const ApiV1SseApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1SseApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the number of active SSE connections. Requires ADMIN role.
     * @summary SSE health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sseControllerHealth(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sseControllerHealth(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1SseApi.sseControllerHealth']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Establishes a Server-Sent Events connection to receive real-time updates
     * @summary Server-Sent Events stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sseControllerStream(
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sseControllerStream(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1SseApi.sseControllerStream']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1SseApi - factory interface
 * @export
 */
export const ApiV1SseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ApiV1SseApiFp(configuration);
  return {
    /**
     * Returns the number of active SSE connections. Requires ADMIN role.
     * @summary SSE health check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sseControllerHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.sseControllerHealth(options).then((request) => request(axios, basePath));
    },
    /**
     * Establishes a Server-Sent Events connection to receive real-time updates
     * @summary Server-Sent Events stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sseControllerStream(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.sseControllerStream(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1SseApi - interface
 * @export
 * @interface ApiV1SseApi
 */
export interface ApiV1SseApiInterface {
  /**
   * Returns the number of active SSE connections. Requires ADMIN role.
   * @summary SSE health check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1SseApiInterface
   */
  sseControllerHealth(options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   * Establishes a Server-Sent Events connection to receive real-time updates
   * @summary Server-Sent Events stream
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1SseApiInterface
   */
  sseControllerStream(options?: RawAxiosRequestConfig): AxiosPromise<void>;
}

/**
 * ApiV1SseApi - object-oriented interface
 * @export
 * @class ApiV1SseApi
 * @extends {BaseAPI}
 */
export class ApiV1SseApi extends BaseAPI implements ApiV1SseApiInterface {
  /**
   * Returns the number of active SSE connections. Requires ADMIN role.
   * @summary SSE health check
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1SseApi
   */
  public sseControllerHealth(options?: RawAxiosRequestConfig) {
    return ApiV1SseApiFp(this.configuration)
      .sseControllerHealth(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Establishes a Server-Sent Events connection to receive real-time updates
   * @summary Server-Sent Events stream
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1SseApi
   */
  public sseControllerStream(options?: RawAxiosRequestConfig) {
    return ApiV1SseApiFp(this.configuration)
      .sseControllerStream(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1WorkflowsApi - axios parameter creator
 * @export
 */
export const ApiV1WorkflowsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a workflow by ID
     * @param {string} id The ID of the workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowControllerDeleteWorkflow: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('workflowControllerDeleteWorkflow', 'id', id);
      const localVarPath = `/api/v1/workflows/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a workflow by ID
     * @param {string} id The ID of the workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowControllerGetWorkflowById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('workflowControllerGetWorkflowById', 'id', id);
      const localVarPath = `/api/v1/workflows/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve workflows with filters, sorting, and pagination
     * @param {string} [filter] JSON string of WorkflowFilterDto object
     * @param {string} [sortBy] JSON string array of WorkflowSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowControllerGetWorkflows: async (
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/workflows`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1WorkflowsApi - functional programming interface
 * @export
 */
export const ApiV1WorkflowsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1WorkflowsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete a workflow by ID
     * @param {string} id The ID of the workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowControllerDeleteWorkflow(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowControllerDeleteWorkflow(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkflowsApi.workflowControllerDeleteWorkflow']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a workflow by ID
     * @param {string} id The ID of the workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowControllerGetWorkflowById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowControllerGetWorkflowById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkflowsApi.workflowControllerGetWorkflowById']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Retrieve workflows with filters, sorting, and pagination
     * @param {string} [filter] JSON string of WorkflowFilterDto object
     * @param {string} [sortBy] JSON string array of WorkflowSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowControllerGetWorkflows(
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowControllerGetWorkflows200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowControllerGetWorkflows(
        filter,
        sortBy,
        page,
        limit,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkflowsApi.workflowControllerGetWorkflows']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1WorkflowsApi - factory interface
 * @export
 */
export const ApiV1WorkflowsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1WorkflowsApiFp(configuration);
  return {
    /**
     *
     * @summary Delete a workflow by ID
     * @param {ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowControllerDeleteWorkflow(
      requestParameters: ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .workflowControllerDeleteWorkflow(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a workflow by ID
     * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowControllerGetWorkflowById(
      requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkflowDto> {
      return localVarFp
        .workflowControllerGetWorkflowById(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve workflows with filters, sorting, and pagination
     * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowControllerGetWorkflows(
      requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkflowControllerGetWorkflows200Response> {
      return localVarFp
        .workflowControllerGetWorkflows(
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.page,
          requestParameters.limit,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1WorkflowsApi - interface
 * @export
 * @interface ApiV1WorkflowsApi
 */
export interface ApiV1WorkflowsApiInterface {
  /**
   *
   * @summary Delete a workflow by ID
   * @param {ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkflowsApiInterface
   */
  workflowControllerDeleteWorkflow(
    requestParameters: ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get a workflow by ID
   * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkflowsApiInterface
   */
  workflowControllerGetWorkflowById(
    requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WorkflowDto>;

  /**
   *
   * @summary Retrieve workflows with filters, sorting, and pagination
   * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkflowsApiInterface
   */
  workflowControllerGetWorkflows(
    requestParameters?: ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WorkflowControllerGetWorkflows200Response>;
}

/**
 * Request parameters for workflowControllerDeleteWorkflow operation in ApiV1WorkflowsApi.
 * @export
 * @interface ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest
 */
export interface ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest {
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof ApiV1WorkflowsApiWorkflowControllerDeleteWorkflow
   */
  readonly id: string;
}

/**
 * Request parameters for workflowControllerGetWorkflowById operation in ApiV1WorkflowsApi.
 * @export
 * @interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest
 */
export interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest {
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflowById
   */
  readonly id: string;
}

/**
 * Request parameters for workflowControllerGetWorkflows operation in ApiV1WorkflowsApi.
 * @export
 * @interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest
 */
export interface ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest {
  /**
   * JSON string of WorkflowFilterDto object
   * @type {string}
   * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
   */
  readonly filter?: string;

  /**
   * JSON string array of WorkflowSortByDto objects
   * @type {string}
   * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
   */
  readonly sortBy?: string;

  /**
   * Page number for pagination (starts at 1)
   * @type {number}
   * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ApiV1WorkflowsApiWorkflowControllerGetWorkflows
   */
  readonly limit?: number;
}

/**
 * ApiV1WorkflowsApi - object-oriented interface
 * @export
 * @class ApiV1WorkflowsApi
 * @extends {BaseAPI}
 */
export class ApiV1WorkflowsApi extends BaseAPI implements ApiV1WorkflowsApiInterface {
  /**
   *
   * @summary Delete a workflow by ID
   * @param {ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkflowsApi
   */
  public workflowControllerDeleteWorkflow(
    requestParameters: ApiV1WorkflowsApiWorkflowControllerDeleteWorkflowRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkflowsApiFp(this.configuration)
      .workflowControllerDeleteWorkflow(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a workflow by ID
   * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkflowsApi
   */
  public workflowControllerGetWorkflowById(
    requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkflowsApiFp(this.configuration)
      .workflowControllerGetWorkflowById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve workflows with filters, sorting, and pagination
   * @param {ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkflowsApi
   */
  public workflowControllerGetWorkflows(
    requestParameters: ApiV1WorkflowsApiWorkflowControllerGetWorkflowsRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkflowsApiFp(this.configuration)
      .workflowControllerGetWorkflows(
        requestParameters.filter,
        requestParameters.sortBy,
        requestParameters.page,
        requestParameters.limit,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ApiV1WorkspacesApi - axios parameter creator
 * @export
 */
export const ApiV1WorkspacesApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete multiple workspaces by IDs
     * @param {WorkspaceControllerBatchDeleteWorkspacesRequest} workspaceControllerBatchDeleteWorkspacesRequest Array of workspace IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerBatchDeleteWorkspaces: async (
      workspaceControllerBatchDeleteWorkspacesRequest: WorkspaceControllerBatchDeleteWorkspacesRequest,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceControllerBatchDeleteWorkspacesRequest' is not null or undefined
      assertParamExists(
        'workspaceControllerBatchDeleteWorkspaces',
        'workspaceControllerBatchDeleteWorkspacesRequest',
        workspaceControllerBatchDeleteWorkspacesRequest,
      );
      const localVarPath = `/api/v1/workspaces/batch`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        workspaceControllerBatchDeleteWorkspacesRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new workspace
     * @param {WorkspaceCreateDto} workspaceCreateDto Workspace data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerCreateWorkspace: async (
      workspaceCreateDto: WorkspaceCreateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'workspaceCreateDto' is not null or undefined
      assertParamExists('workspaceControllerCreateWorkspace', 'workspaceCreateDto', workspaceCreateDto);
      const localVarPath = `/api/v1/workspaces`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a workspace by ID
     * @param {string} id The ID of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerDeleteWorkspace: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('workspaceControllerDeleteWorkspace', 'id', id);
      const localVarPath = `/api/v1/workspaces/id/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a workspace by ID
     * @param {string} id The ID of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerGetWorkspaceById: async (
      id: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('workspaceControllerGetWorkspaceById', 'id', id);
      const localVarPath = `/api/v1/workspaces/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve workspaces with filters, sorting, pagination, and search
     * @param {string} [filter] JSON string of WorkspaceFilterDto object
     * @param {string} [sortBy] JSON string array of WorkspaceSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter workspaces by title or other searchable fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerGetWorkspaces: async (
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      search?: string,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/v1/workspaces`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (filter !== undefined) {
        localVarQueryParameter['filter'] = filter;
      }

      if (sortBy !== undefined) {
        localVarQueryParameter['sortBy'] = sortBy;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (search !== undefined) {
        localVarQueryParameter['search'] = search;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a workspace by ID
     * @param {string} id The ID of the workspace
     * @param {WorkspaceUpdateDto} workspaceUpdateDto Updated workspace data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerUpdateWorkspace: async (
      id: string,
      workspaceUpdateDto: WorkspaceUpdateDto,
      options: RawAxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('workspaceControllerUpdateWorkspace', 'id', id);
      // verify required parameter 'workspaceUpdateDto' is not null or undefined
      assertParamExists('workspaceControllerUpdateWorkspace', 'workspaceUpdateDto', workspaceUpdateDto);
      const localVarPath = `/api/v1/workspaces/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateDto, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ApiV1WorkspacesApi - functional programming interface
 * @export
 */
export const ApiV1WorkspacesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ApiV1WorkspacesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete multiple workspaces by IDs
     * @param {WorkspaceControllerBatchDeleteWorkspacesRequest} workspaceControllerBatchDeleteWorkspacesRequest Array of workspace IDs to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workspaceControllerBatchDeleteWorkspaces(
      workspaceControllerBatchDeleteWorkspacesRequest: WorkspaceControllerBatchDeleteWorkspacesRequest,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceControllerBatchDeleteWorkspaces200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerBatchDeleteWorkspaces(
        workspaceControllerBatchDeleteWorkspacesRequest,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkspacesApi.workspaceControllerBatchDeleteWorkspaces']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Create a new workspace
     * @param {WorkspaceCreateDto} workspaceCreateDto Workspace data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workspaceControllerCreateWorkspace(
      workspaceCreateDto: WorkspaceCreateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerCreateWorkspace(
        workspaceCreateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkspacesApi.workspaceControllerCreateWorkspace']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a workspace by ID
     * @param {string} id The ID of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workspaceControllerDeleteWorkspace(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerDeleteWorkspace(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkspacesApi.workspaceControllerDeleteWorkspace']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a workspace by ID
     * @param {string} id The ID of the workspace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workspaceControllerGetWorkspaceById(
      id: string,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerGetWorkspaceById(id, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkspacesApi.workspaceControllerGetWorkspaceById']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Retrieve workspaces with filters, sorting, pagination, and search
     * @param {string} [filter] JSON string of WorkspaceFilterDto object
     * @param {string} [sortBy] JSON string array of WorkspaceSortByDto objects
     * @param {number} [page] Page number for pagination (starts at 1)
     * @param {number} [limit] Number of items per page
     * @param {string} [search] Search term to filter workspaces by title or other searchable fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workspaceControllerGetWorkspaces(
      filter?: string,
      sortBy?: string,
      page?: number,
      limit?: number,
      search?: string,
      options?: RawAxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceControllerGetWorkspaces200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerGetWorkspaces(
        filter,
        sortBy,
        page,
        limit,
        search,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkspacesApi.workspaceControllerGetWorkspaces']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update a workspace by ID
     * @param {string} id The ID of the workspace
     * @param {WorkspaceUpdateDto} workspaceUpdateDto Updated workspace data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workspaceControllerUpdateWorkspace(
      id: string,
      workspaceUpdateDto: WorkspaceUpdateDto,
      options?: RawAxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceDto>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workspaceControllerUpdateWorkspace(
        id,
        workspaceUpdateDto,
        options,
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ApiV1WorkspacesApi.workspaceControllerUpdateWorkspace']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration,
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ApiV1WorkspacesApi - factory interface
 * @export
 */
export const ApiV1WorkspacesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = ApiV1WorkspacesApiFp(configuration);
  return {
    /**
     *
     * @summary Delete multiple workspaces by IDs
     * @param {ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerBatchDeleteWorkspaces(
      requestParameters: ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkspaceControllerBatchDeleteWorkspaces200Response> {
      return localVarFp
        .workspaceControllerBatchDeleteWorkspaces(
          requestParameters.workspaceControllerBatchDeleteWorkspacesRequest,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new workspace
     * @param {ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerCreateWorkspace(
      requestParameters: ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkspaceDto> {
      return localVarFp
        .workspaceControllerCreateWorkspace(requestParameters.workspaceCreateDto, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerDeleteWorkspace(
      requestParameters: ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<void> {
      return localVarFp
        .workspaceControllerDeleteWorkspace(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerGetWorkspaceById(
      requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkspaceDto> {
      return localVarFp
        .workspaceControllerGetWorkspaceById(requestParameters.id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve workspaces with filters, sorting, pagination, and search
     * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerGetWorkspaces(
      requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest = {},
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkspaceControllerGetWorkspaces200Response> {
      return localVarFp
        .workspaceControllerGetWorkspaces(
          requestParameters.filter,
          requestParameters.sortBy,
          requestParameters.page,
          requestParameters.limit,
          requestParameters.search,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a workspace by ID
     * @param {ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workspaceControllerUpdateWorkspace(
      requestParameters: ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest,
      options?: RawAxiosRequestConfig,
    ): AxiosPromise<WorkspaceDto> {
      return localVarFp
        .workspaceControllerUpdateWorkspace(requestParameters.id, requestParameters.workspaceUpdateDto, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ApiV1WorkspacesApi - interface
 * @export
 * @interface ApiV1WorkspacesApi
 */
export interface ApiV1WorkspacesApiInterface {
  /**
   *
   * @summary Delete multiple workspaces by IDs
   * @param {ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApiInterface
   */
  workspaceControllerBatchDeleteWorkspaces(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WorkspaceControllerBatchDeleteWorkspaces200Response>;

  /**
   *
   * @summary Create a new workspace
   * @param {ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApiInterface
   */
  workspaceControllerCreateWorkspace(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WorkspaceDto>;

  /**
   *
   * @summary Delete a workspace by ID
   * @param {ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApiInterface
   */
  workspaceControllerDeleteWorkspace(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get a workspace by ID
   * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApiInterface
   */
  workspaceControllerGetWorkspaceById(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WorkspaceDto>;

  /**
   *
   * @summary Retrieve workspaces with filters, sorting, pagination, and search
   * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApiInterface
   */
  workspaceControllerGetWorkspaces(
    requestParameters?: ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WorkspaceControllerGetWorkspaces200Response>;

  /**
   *
   * @summary Update a workspace by ID
   * @param {ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApiInterface
   */
  workspaceControllerUpdateWorkspace(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ): AxiosPromise<WorkspaceDto>;
}

/**
 * Request parameters for workspaceControllerBatchDeleteWorkspaces operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest {
  /**
   * Array of workspace IDs to delete
   * @type {WorkspaceControllerBatchDeleteWorkspacesRequest}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspaces
   */
  readonly workspaceControllerBatchDeleteWorkspacesRequest: WorkspaceControllerBatchDeleteWorkspacesRequest;
}

/**
 * Request parameters for workspaceControllerCreateWorkspace operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest {
  /**
   * Workspace data
   * @type {WorkspaceCreateDto}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerCreateWorkspace
   */
  readonly workspaceCreateDto: WorkspaceCreateDto;
}

/**
 * Request parameters for workspaceControllerDeleteWorkspace operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest {
  /**
   * The ID of the workspace
   * @type {string}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspace
   */
  readonly id: string;
}

/**
 * Request parameters for workspaceControllerGetWorkspaceById operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest {
  /**
   * The ID of the workspace
   * @type {string}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceById
   */
  readonly id: string;
}

/**
 * Request parameters for workspaceControllerGetWorkspaces operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest {
  /**
   * JSON string of WorkspaceFilterDto object
   * @type {string}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
   */
  readonly filter?: string;

  /**
   * JSON string array of WorkspaceSortByDto objects
   * @type {string}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
   */
  readonly sortBy?: string;

  /**
   * Page number for pagination (starts at 1)
   * @type {number}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
   */
  readonly page?: number;

  /**
   * Number of items per page
   * @type {number}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
   */
  readonly limit?: number;

  /**
   * Search term to filter workspaces by title or other searchable fields
   * @type {string}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerGetWorkspaces
   */
  readonly search?: string;
}

/**
 * Request parameters for workspaceControllerUpdateWorkspace operation in ApiV1WorkspacesApi.
 * @export
 * @interface ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest
 */
export interface ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest {
  /**
   * The ID of the workspace
   * @type {string}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspace
   */
  readonly id: string;

  /**
   * Updated workspace data
   * @type {WorkspaceUpdateDto}
   * @memberof ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspace
   */
  readonly workspaceUpdateDto: WorkspaceUpdateDto;
}

/**
 * ApiV1WorkspacesApi - object-oriented interface
 * @export
 * @class ApiV1WorkspacesApi
 * @extends {BaseAPI}
 */
export class ApiV1WorkspacesApi extends BaseAPI implements ApiV1WorkspacesApiInterface {
  /**
   *
   * @summary Delete multiple workspaces by IDs
   * @param {ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApi
   */
  public workspaceControllerBatchDeleteWorkspaces(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerBatchDeleteWorkspacesRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkspacesApiFp(this.configuration)
      .workspaceControllerBatchDeleteWorkspaces(
        requestParameters.workspaceControllerBatchDeleteWorkspacesRequest,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new workspace
   * @param {ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApi
   */
  public workspaceControllerCreateWorkspace(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerCreateWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkspacesApiFp(this.configuration)
      .workspaceControllerCreateWorkspace(requestParameters.workspaceCreateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a workspace by ID
   * @param {ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApi
   */
  public workspaceControllerDeleteWorkspace(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerDeleteWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkspacesApiFp(this.configuration)
      .workspaceControllerDeleteWorkspace(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a workspace by ID
   * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApi
   */
  public workspaceControllerGetWorkspaceById(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspaceByIdRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkspacesApiFp(this.configuration)
      .workspaceControllerGetWorkspaceById(requestParameters.id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve workspaces with filters, sorting, pagination, and search
   * @param {ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApi
   */
  public workspaceControllerGetWorkspaces(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerGetWorkspacesRequest = {},
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkspacesApiFp(this.configuration)
      .workspaceControllerGetWorkspaces(
        requestParameters.filter,
        requestParameters.sortBy,
        requestParameters.page,
        requestParameters.limit,
        requestParameters.search,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a workspace by ID
   * @param {ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApiV1WorkspacesApi
   */
  public workspaceControllerUpdateWorkspace(
    requestParameters: ApiV1WorkspacesApiWorkspaceControllerUpdateWorkspaceRequest,
    options?: RawAxiosRequestConfig,
  ) {
    return ApiV1WorkspacesApiFp(this.configuration)
      .workspaceControllerUpdateWorkspace(requestParameters.id, requestParameters.workspaceUpdateDto, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
